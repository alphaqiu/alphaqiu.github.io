<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"alpha.checkitout.dev","root":"/","scheme":"Gemini","version":"7.7.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="PostgreSQL 是一个现代化的数据库，开源，免费试用，社区活跃，和Oracle具有同等强大的功能。支持JSON格式和自定义类型，支持并行查询，聚合函数、窗口函数和数据透视表非常适合作为统计数据的数据源。 合理规划数据是作为数据库使用的重要手段。目前Filscan作为首款后端使用PostgreSQL数据库的项目，目前已经支撑了亿级以上的Filecoin庞大数据量，后续随着Filecoin链继续">
<meta property="og:type" content="article">
<meta property="og:title" content="基于PG自动创建分区表的一种实现">
<meta property="og:url" content="https://alpha.checkitout.dev/auto-create-partition-tables/index.html">
<meta property="og:site_name" content="Check it out">
<meta property="og:description" content="PostgreSQL 是一个现代化的数据库，开源，免费试用，社区活跃，和Oracle具有同等强大的功能。支持JSON格式和自定义类型，支持并行查询，聚合函数、窗口函数和数据透视表非常适合作为统计数据的数据源。 合理规划数据是作为数据库使用的重要手段。目前Filscan作为首款后端使用PostgreSQL数据库的项目，目前已经支撑了亿级以上的Filecoin庞大数据量，后续随着Filecoin链继续">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://alpha.checkitout.dev/public/images/%E5%88%86%E5%8C%BA%E8%A1%A8pg%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B.png">
<meta property="og:image" content="https://alpha.checkitout.dev/public/images/%E5%88%86%E5%8C%BA%E8%A1%A8pg%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B2.png">
<meta property="article:published_time" content="2023-01-31T11:45:41.000Z">
<meta property="article:modified_time" content="2023-10-04T13:48:15.417Z">
<meta property="article:author" content="alpha">
<meta property="article:tag" content="PostgreSQL">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://alpha.checkitout.dev/public/images/%E5%88%86%E5%8C%BA%E8%A1%A8pg%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B.png">

<link rel="canonical" href="https://alpha.checkitout.dev/auto-create-partition-tables/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true
  };
</script>

  <title>基于PG自动创建分区表的一种实现 | Check it out</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-151212624-1"></script>
    <script>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'UA-151212624-1');
      }
    </script>






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><!-- hexo-inject:begin --><!-- hexo-inject:end --></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Check it out</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">工作笔记</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/404.html" rel="section"><i class="fa fa-fw fa-heartbeat"></i>公益 404</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/alphaqiu" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://alpha.checkitout.dev/auto-create-partition-tables/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="alpha">
      <meta itemprop="description" content="记录工作中研究和学习的内容，把他们以文字的形式记录下来，备忘。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Check it out">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          基于PG自动创建分区表的一种实现
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-01-31 19:45:41" itemprop="dateCreated datePublished" datetime="2023-01-31T19:45:41+08:00">2023-01-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-10-04 21:48:15" itemprop="dateModified" datetime="2023-10-04T21:48:15+08:00">2023-10-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B8%AE%E5%8A%A9%E6%89%8B%E5%86%8C/" itemprop="url" rel="index"><span itemprop="name">帮助手册</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/auto-create-partition-tables/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="/auto-create-partition-tables/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>PostgreSQL 是一个现代化的数据库，开源，免费试用，社区活跃，和Oracle具有同等强大的功能。支持JSON格式和自定义类型，支持并行查询，聚合函数、窗口函数和数据透视表非常适合作为统计数据的数据源。</p>
<p>合理规划数据是作为数据库使用的重要手段。目前Filscan作为首款后端使用PostgreSQL数据库的项目，目前已经支撑了亿级以上的Filecoin庞大数据量，后续随着Filecoin链继续发展，数据还将继续膨胀。</p>
<p>Filecoin的状态数据的数量非常庞大，如果在一张表内保存，会非常影响查询效率。为达到保存一段时间内的数据，且可以根据时间范围伸缩，提高查询效率，需要对巨量数据表进行表分区。让数据库按需自动的创建新的表来存放按照规则划分的数据，是可以提高自动化维护表程度，减少人为的干扰和出错的可能。</p>
<h1 id="表分区方案"><a href="#表分区方案" class="headerlink" title="表分区方案"></a>表分区方案</h1><p>表分区方案是一直存在的，有三种方式：</p>
<p><strong>预先创建一批分区表</strong></p>
<p>这种方式最大的弊端是需要定期的创建一批新分区表以适应新数据范围分区，其次分区表不能按实际数据区间创建分区表，所有的数据范围都必须紧密存在，才不会漏存对应的数据到分区中。定期创建分区是容易被忽视的一个环节，一旦忘记定期创建，尤其是定期周期较长，就会导致数据丢失。如果有默认分区存在，新表记录会被保存到默认分区内，对后续可持续维护带来了额外的停机时间开销。</p>
<p><strong>使用程序对表进行分区</strong></p>
<p>这种方式没有问题，不过需要做一些额外适配工作，以适应不同的分区表的动态创建，分区表逻辑的更新依赖程序的更新。而基于数据库实现自动表分区，只需要即时更新存储过程或函数就可立即生效，也能够享受数据库自身的特性带来的便捷性，减少开发周期，降低维护成本。</p>
<p><strong>第三方插件</strong></p>
<p><a target="_blank" rel="noopener" href="https://github.com/postgrespro/pg_pathman">pg_pathman</a> 是一个PostgreSQL数据库的第三方插件。该插件的好处是封装实现了一套维护分区表的完整操作。阿里云RDS PostgreSQL版本支持安装该插件，下面是阿里云RDS各个PostgreSQL版本所支持该插件的情况。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>插件名</th>
<th>14</th>
<th>13</th>
<th>12</th>
<th>11</th>
<th>10</th>
<th>9.4</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>pg_pathman</td>
<td>无</td>
<td>1.5</td>
<td>1.5</td>
<td>1.5</td>
<td>1.5</td>
<td>无</td>
<td>高性能分区表插件</td>
</tr>
</tbody>
</table>
</div>
<p><a target="_blank" rel="noopener" href="https://help.aliyun.com/document_detail/142340.html">https://help.aliyun.com/document_detail/142340.html</a></p>
<p>这里有关于该插件的全部用法：<a target="_blank" rel="noopener" href="https://help.aliyun.com/document_detail/140900.html">https://help.aliyun.com/document_detail/140900.html</a></p>
<p>但是该插件官网做了以下提示：</p>
<blockquote>
<h3 id="注意：该项目不再处于开发阶段"><a href="#注意：该项目不再处于开发阶段" class="headerlink" title="注意：该项目不再处于开发阶段"></a>注意：该项目不再处于开发阶段</h3><p><code>pg_pathman</code>支持 Postgres 版本 [9.5..13]，但很可能不会移植到 14 及更高版本。<a target="_blank" rel="noopener" href="https://www.postgresql.org/docs/current/ddl-partitioning.html">声明式分区</a>现在已经相当成熟，几乎所有的东西都在<code>pg_pathman</code>; 我们鼓励用户切换到它。我们仍在维护该项目（修复受支持版本中的错误），但这里不会发生新的开发。</p>
</blockquote>
<p>这个项目官方预计停止后续的支持，目前处于维护阶段，提示官方声明式分区版本已经做得足够好，可以不需要依赖第三方插件。从这点上说，选择声明式分区无疑是最优的选择，不会因为服务器版本升级而需要额外升级依赖第三方实现。</p>
<h1 id="声明式分区（DDL-Partition）"><a href="#声明式分区（DDL-Partition）" class="headerlink" title="声明式分区（DDL-Partition）"></a>声明式分区（DDL-Partition）</h1><p>PostgreSQL提供了一种方法指定如何把一个表划分成称为分区的片段。被划分的表被称作<em>分区表</em>。</p>
<p>表分区是解决一些因单表过大引用的性能问题的方式，比如某张表过大就会造成查询变慢，可能分区是一种解决方案。一般建议当单表大小超过内存就可以考虑表分区了。</p>
<p>PostgreSQL表分区有两种实现方式，声明式分区和表继承。它们各自有优缺点，比如，对声明式分区来说，分区必须具有和分区表正好相同的列集合，而在表继承中，子表可以有父表中没有出现过的额外列。除此之外，声明式分区也有着优秀的特点，可以减轻对分区表的维护代价、提供了操作的便捷性和查询性能，使用表继承将要做更多的工作才能达到同样的效果。</p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><h3 id="默认分区"><a href="#默认分区" class="headerlink" title="默认分区"></a>默认分区</h3><p>PosgtreSQL 11开始，支持为声明式分区表创建一个默认（DEFAULT）的分区，用于存储无法匹配其他任何分区的数据。只有 RANGE 分区表和 LIST 分区表需要默认分区。创建默认分区时使用 DEFAULT 子句替代 FOR VALUES 子句。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> example_table(</span><br><span class="line">    epoch <span class="type">BIGINT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> ,</span><br><span class="line">    data text</span><br><span class="line">) <span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">RANGE</span> (epoch);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> example_table_1_100 <span class="keyword">PARTITION</span> <span class="keyword">OF</span> example_table <span class="keyword">FOR</span> <span class="keyword">VALUES</span> <span class="keyword">FROM</span> (MINVALUE) <span class="keyword">TO</span> (<span class="number">101</span>);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> example_table_101_200 <span class="keyword">PARTITION</span> <span class="keyword">OF</span> example_table <span class="keyword">FOR</span> <span class="keyword">VALUES</span> <span class="keyword">FROM</span> (<span class="number">101</span>) <span class="keyword">TO</span> (<span class="number">201</span>);</span><br><span class="line"><span class="comment">-- 创建默认分区时使用 DEFAULT 子句替代 FOR VALUES 子句。</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> example_table_default <span class="keyword">PARTITION</span> <span class="keyword">OF</span> example_table <span class="keyword">DEFAULT</span> ;</span><br></pre></td></tr></table></figure>
<p>如果没有创建默认分区，在插入<code>epoch</code>=201时，会报错，提示插入错误。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- [23514] 错误: 没有为行找到关系&quot;example_table&quot;的分区</span></span><br><span class="line"><span class="comment">-- 详细：失败行的分区键包含(epoch) = (201).</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> example_table(epoch, data) <span class="keyword">VALUES</span> (<span class="number">201</span>, <span class="string">&#x27;good&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>默认分区存在以下限制：</p>
<ul>
<li>一个分区表只能拥有<strong>一个</strong> DEFAULT 分区；</li>
<li>对于已经存储在 DEFAULT 分区中的数据，不能再创建相应的分区；参见下文示例；</li>
<li>如果将已有的表挂载为 DEFAULT 分区，将会检查该表中的所有数据；如果在已有的分区中存在相同的数据，将会产生一个错误；</li>
<li>哈希分区表不支持 DEFAULT 分区，实际上也不需要支持。</li>
</ul>
<p>以列表分区为例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> example_table_list(</span><br><span class="line">    miner <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> ,</span><br><span class="line">    epoch <span class="type">BIGINT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> ,</span><br><span class="line">    data <span class="type">varchar</span>(<span class="number">50</span>)</span><br><span class="line">) <span class="keyword">PARTITION</span> <span class="keyword">BY</span> LIST (miner);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> example_table_list_02438 <span class="keyword">PARTITION</span> <span class="keyword">OF</span> example_table_list <span class="keyword">FOR</span> <span class="keyword">VALUES</span> <span class="keyword">IN</span> (<span class="string">&#x27;f02438&#x27;</span>);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> example_table_list_025002_025005 <span class="keyword">PARTITION</span> <span class="keyword">OF</span> example_table_list <span class="keyword">FOR</span> <span class="keyword">VALUES</span> <span class="keyword">IN</span> (<span class="string">&#x27;f025002&#x27;</span>, <span class="string">&#x27;f025005&#x27;</span>);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> example_table_list_default <span class="keyword">PARTITION</span> <span class="keyword">OF</span> example_table_list <span class="keyword">DEFAULT</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> example_table_list <span class="keyword">VALUES</span> (<span class="string">&#x27;f03721&#x27;</span>, <span class="number">98</span>, <span class="string">&#x27;Green&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>如果此时未创建对<code>f03721</code>的分区表，上面的语句会插入到<code>example_table_list_default</code>表内。如果此时开始创建</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> example_table_list_03721 <span class="keyword">PARTITION</span> <span class="keyword">OF</span> example_table_list <span class="keyword">FOR</span> <span class="keyword">VALUES</span> <span class="keyword">IN</span> (<span class="string">&#x27;f03721&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>操作将会失败。因为添加新的分区需要修改默认分区的范围。但是默认分区中已经存在<code>f02731</code>的分区数据项。</p>
<blockquote>
<p>错误: 某些行将违反默认分区”example_table_list_default”的更新分区约束</p>
</blockquote>
<p>为了解决这个问题，可以先将默认分区从分区表中卸载（<strong>DETACH PARTITION</strong>），创建新的分区，将默认分区中的相应的数据移动到新的分区，最后重新挂载默认分区。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 临时卸载默认分区</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> example_table_list DETACH <span class="keyword">PARTITION</span> example_table_list_default;</span><br><span class="line"><span class="comment">-- 创建一个新的列表分区表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> example_table_list_03721 <span class="keyword">PARTITION</span> <span class="keyword">OF</span> example_table_list <span class="keyword">FOR</span> <span class="keyword">VALUES</span> <span class="keyword">IN</span> (<span class="string">&#x27;f03721&#x27;</span>);</span><br><span class="line"><span class="comment">-- 查询默认分区表内的对应数据并插入到新分区表内</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> example_table_list_03721</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> example_table_list_default <span class="keyword">WHERE</span> miner <span class="operator">=</span> <span class="string">&#x27;f03721&#x27;</span>;</span><br><span class="line"><span class="comment">-- 删除默认分区表内的数据</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> example_table_list_default <span class="keyword">WHERE</span> miner <span class="operator">=</span> <span class="string">&#x27;f03721&#x27;</span>;</span><br><span class="line"><span class="comment">-- 重新挂载默认分区表</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> example_table_list ATTACH <span class="keyword">PARTITION</span> example_table_list_default <span class="keyword">DEFAULT</span> ;</span><br></pre></td></tr></table></figure>
<h3 id="分区自动索引"><a href="#分区自动索引" class="headerlink" title="分区自动索引"></a>分区自动索引</h3><p>在 PostgreSQL10 中，分区上的索引需要基于各个分区手动创建，而不能基于分区的父表创建索引。PostgreSQL 11 及以后的版本，声明式分区表可以基于分区表创建索引。分区表上的索引并不会创建一个物理上的索引，而是为每个分区上的索引创建一个模板。表继承方式的分区表需要为每一张分区表创建索引和约束。</p>
<p>如果在声明式分区表上创建了一个索引，PostgreSQL 自动为每个分区创建具有相同属性的索引。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 在主表上创建索引，会在分表上自动创建对应的索引。</span></span><br><span class="line"><span class="comment">-- 在创建新的分区表时，也会自动创建好对应的索引。</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> INDEX example_table_epoch <span class="keyword">ON</span> example_table(epoch <span class="keyword">DESC</span>);</span><br><span class="line"><span class="comment">-- 在主表上执行删除索引时，也会自动在分区表上删除对应的索引。</span></span><br><span class="line"><span class="keyword">DROP</span> INDEX example_table_epoch;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>自动创建的索引，名称按照 “{partition name}<em>{column name}_idx” 的模式定义。多个字段的复合索引使用下划线（</em>）连接字段名称。如果索引名称已经存在，在名称的最后添加一个数字。如果名称过长，使用缩写。</p>
</li>
<li><p>随后新增的分区或者通过 ATTACH PARTITION 挂载的分区都会自动创建相应的索引。</p>
</li>
<li><p>自动创建的索引不能单独删除，可以通过分区表统一删除。</p>
</li>
</ul>
<h3 id="跨分区移动数据"><a href="#跨分区移动数据" class="headerlink" title="跨分区移动数据"></a>跨分区移动数据</h3><p>在 <a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=PostgreSQL&amp;spm=1001.2101.3001.7020">PostgreSQL</a> 10 中，声明式分区表如果 UPDATE 语句修改了分区字段的值，导致数据需要移动到其他分区时，语句将会失败。PostgreSQL 11+ 以后能够正确处理更新分区字段的操作。根据<a target="_blank" rel="noopener" href="https://git.postgresql.org/gitweb/?p=postgresql.git;a=commitdiff;h=2f178441044be">提交记录</a>，这种 UPDATE 语句实际上分为两步执行：从旧的分区中 <code>DELETE</code>相应记录，在新的分区中 <code>INSERT</code>相应记录。另外，跨分区移动数据的 UPDATE 语句将会导致触发器的执行顺序更加复杂。</p>
<h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><p>分区表有下列限制：</p>
<ul>
<li>没有办法创建跨越所有分区的排除约束，只可能单个约束每个叶子分区。</li>
<li>分区表上的惟一约束（也就是主键）必须包括所有分区键列。存在此限制是因为PostgreSQL只能每个分区中分别强制实施唯一性。</li>
<li><code>BEFORE ROW</code> 触发器无法更改哪个分区是新行的最终目标。</li>
<li>不允许在同一个分区树中混杂临时关系和持久关系。因此，如果分区表是持久的，则其分区也必须是持久的，反之亦然。在使用临时关系时，分区数的所有成员都必须来自于同一个会话。</li>
</ul>
<h2 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h2><p>厘清执行流程有助于从宏观上理解在哪个步骤中适合实现自动创建分区表。从数据库提供的机制上，有存储过程和触发器两种武器，分别可以实现在不同阶段处理不同拦截逻辑。</p>
<p>对于声明式分区表，所有被插入的行将被基于分区键的值，路由到<em>分区</em>中。每个分区都有一个由其<em>分区边界</em>定义的数据子集。当前支持的分区方法是范围、列表以及哈希。也就是说分区表的插入/更新操作，又一个内置的路由规则。</p>
<p>根据定义，结合对表的插入/更新操作以及触发器流程，一条数据在插入到分区表时，将经历以下步骤：</p>
<ol>
<li>触发分区主表的statement before insert</li>
<li>自动路由到符合范围的分区子表</li>
<li>触发符合范围的分区子表row before insert</li>
<li>数据插入</li>
<li>触发符合范围的分区子表row after insert</li>
<li>触发分区主表的statement after insert</li>
</ol>
<p>下面验证一下上述流程。</p>
<h3 id="触发器行为"><a href="#触发器行为" class="headerlink" title="触发器行为"></a>触发器行为</h3><h4 id="创建分区表"><a href="#创建分区表" class="headerlink" title="创建分区表"></a><strong>创建分区表</strong></h4><p>举个例子，创建一张测试分区表，并创建三个分区，<strong>不创建</strong>默认分区。由于默认分区的限制，对于已经存储在 DEFAULT 分区中的数据，不能再创建相应的分区，需要先DETACH默认分区手动做数据转移，然后才可以创建新范围分区，这个步骤无法实现自动创建。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> example_table CASCADE ;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> example_table(col1 <span class="type">INT</span>) <span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">RANGE</span> (col1);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> example_table_1 <span class="keyword">PARTITION</span> <span class="keyword">OF</span> example_table <span class="keyword">FOR</span> <span class="keyword">VALUES</span> <span class="keyword">FROM</span> (<span class="number">0</span>) <span class="keyword">TO</span> (<span class="number">10</span>);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> example_table_2 <span class="keyword">PARTITION</span> <span class="keyword">OF</span> example_table <span class="keyword">FOR</span> <span class="keyword">VALUES</span> <span class="keyword">FROM</span> (<span class="number">11</span>) <span class="keyword">TO</span> (<span class="number">20</span>);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> example_table_3 <span class="keyword">PARTITION</span> <span class="keyword">OF</span> example_table <span class="keyword">FOR</span> <span class="keyword">VALUES</span> <span class="keyword">FROM</span> (<span class="number">21</span>) <span class="keyword">TO</span> (<span class="number">30</span>);</span><br></pre></td></tr></table></figure>
<h4 id="创建触发器函数"><a href="#创建触发器函数" class="headerlink" title="创建触发器函数"></a><strong>创建触发器函数</strong></h4><p>创建一个用于观察触发器触发阶段的函数</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE <span class="keyword">FUNCTION</span> notice_trigger() <span class="keyword">RETURNS</span> <span class="keyword">TRIGGER</span> <span class="keyword">AS</span></span><br><span class="line">$$</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    RAISE NOTICE <span class="string">&#x27;trigger name:%; table_name:%; level:%; op:%; when:%; value:%&#x27;</span>,</span><br><span class="line">        tg_name, tg_table_name, tg_level, tg_op, tg_when, <span class="keyword">new</span>;</span><br><span class="line">    <span class="keyword">RETURN</span> <span class="keyword">new</span>;</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line">$$ <span class="keyword">LANGUAGE</span> plpgsql;</span><br></pre></td></tr></table></figure>
<h4 id="创建触发器"><a href="#创建触发器" class="headerlink" title="创建触发器"></a><strong>创建触发器</strong></h4><p>在分区表主表<code>example_table</code>上绑定测试分区表INSERT和UPDATE触发器，分别是语句级别和行级别，与before 和after的组合。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> show_notice_before_insert_stmt</span><br><span class="line">    BEFORE <span class="keyword">INSERT</span></span><br><span class="line">    <span class="keyword">ON</span> example_table</span><br><span class="line">    <span class="keyword">FOR</span> STATEMENT</span><br><span class="line"><span class="keyword">EXECUTE</span> <span class="keyword">FUNCTION</span> notice_trigger();</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> show_notice_after_insert_stmt</span><br><span class="line">    AFTER <span class="keyword">INSERT</span></span><br><span class="line">    <span class="keyword">ON</span> example_table</span><br><span class="line">    <span class="keyword">FOR</span> STATEMENT</span><br><span class="line"><span class="keyword">EXECUTE</span> <span class="keyword">FUNCTION</span> notice_trigger();</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> show_notice_before_insert_row</span><br><span class="line">    BEFORE <span class="keyword">INSERT</span></span><br><span class="line">    <span class="keyword">ON</span> example_table</span><br><span class="line">    <span class="keyword">FOR</span> <span class="type">ROW</span></span><br><span class="line"><span class="keyword">EXECUTE</span> <span class="keyword">FUNCTION</span> notice_trigger();</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> show_notice_after_insert_row</span><br><span class="line">    AFTER <span class="keyword">INSERT</span></span><br><span class="line">    <span class="keyword">ON</span> example_table</span><br><span class="line">    <span class="keyword">FOR</span> <span class="type">ROW</span></span><br><span class="line"><span class="keyword">EXECUTE</span> <span class="keyword">FUNCTION</span> notice_trigger();</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> show_notice_before_update_stmt</span><br><span class="line">    BEFORE <span class="keyword">UPDATE</span></span><br><span class="line">    <span class="keyword">ON</span> example_table</span><br><span class="line">    <span class="keyword">FOR</span> STATEMENT</span><br><span class="line"><span class="keyword">EXECUTE</span> <span class="keyword">FUNCTION</span> notice_trigger();</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> show_notice_after_update_stmt</span><br><span class="line">    AFTER <span class="keyword">UPDATE</span></span><br><span class="line">    <span class="keyword">ON</span> example_table</span><br><span class="line">    <span class="keyword">FOR</span> STATEMENT</span><br><span class="line"><span class="keyword">EXECUTE</span> <span class="keyword">FUNCTION</span> notice_trigger();</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> show_notice_before_update_row</span><br><span class="line">    BEFORE <span class="keyword">UPDATE</span></span><br><span class="line">    <span class="keyword">ON</span> example_table</span><br><span class="line">    <span class="keyword">FOR</span> <span class="type">ROW</span></span><br><span class="line"><span class="keyword">EXECUTE</span> <span class="keyword">FUNCTION</span> notice_trigger();</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> show_notice_after_update_row</span><br><span class="line">    AFTER <span class="keyword">UPDATE</span></span><br><span class="line">    <span class="keyword">ON</span> example_table</span><br><span class="line">    <span class="keyword">FOR</span> <span class="type">ROW</span></span><br><span class="line"><span class="keyword">EXECUTE</span> <span class="keyword">FUNCTION</span> notice_trigger();</span><br></pre></td></tr></table></figure>
<p>通过观察表结构定义我们可以看到，主表上创建出8个触发器。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">example<span class="operator">=</span># \d<span class="operator">+</span> example_table</span><br><span class="line">                         Partitioned <span class="keyword">table</span> &quot;public.example_table&quot;</span><br><span class="line"> <span class="keyword">Column</span> <span class="operator">|</span>  Type   <span class="operator">|</span> <span class="keyword">Collation</span> <span class="operator">|</span> Nullable <span class="operator">|</span> <span class="keyword">Default</span> <span class="operator">|</span> Storage <span class="operator">|</span> Stats target <span class="operator">|</span> Description</span><br><span class="line"><span class="comment">--------+---------+-----------+----------+---------+---------+--------------+-------------</span></span><br><span class="line"> col1   <span class="operator">|</span> <span class="type">integer</span> <span class="operator">|</span>           <span class="operator">|</span>          <span class="operator">|</span>         <span class="operator">|</span> plain   <span class="operator">|</span>              <span class="operator">|</span></span><br><span class="line"><span class="keyword">Partition</span> key: <span class="keyword">RANGE</span> (col1)</span><br><span class="line">Triggers:</span><br><span class="line">    show_notice_after_insert_row AFTER <span class="keyword">INSERT</span> <span class="keyword">ON</span> example_table <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span> <span class="keyword">EXECUTE</span> <span class="keyword">FUNCTION</span> notice_trigger()</span><br><span class="line">    show_notice_after_insert_stmt AFTER <span class="keyword">INSERT</span> <span class="keyword">ON</span> example_table <span class="keyword">FOR</span> <span class="keyword">EACH</span> STATEMENT <span class="keyword">EXECUTE</span> <span class="keyword">FUNCTION</span> notice_trigger()</span><br><span class="line">    show_notice_after_update_row AFTER <span class="keyword">UPDATE</span> <span class="keyword">ON</span> example_table <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span> <span class="keyword">EXECUTE</span> <span class="keyword">FUNCTION</span> notice_trigger()</span><br><span class="line">    show_notice_after_update_stmt AFTER <span class="keyword">UPDATE</span> <span class="keyword">ON</span> example_table <span class="keyword">FOR</span> <span class="keyword">EACH</span> STATEMENT <span class="keyword">EXECUTE</span> <span class="keyword">FUNCTION</span> notice_trigger()</span><br><span class="line">    show_notice_before_insert_row BEFORE <span class="keyword">INSERT</span> <span class="keyword">ON</span> example_table <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span> <span class="keyword">EXECUTE</span> <span class="keyword">FUNCTION</span> notice_trigger()</span><br><span class="line">    show_notice_before_insert_stmt BEFORE <span class="keyword">INSERT</span> <span class="keyword">ON</span> example_table <span class="keyword">FOR</span> <span class="keyword">EACH</span> STATEMENT <span class="keyword">EXECUTE</span> <span class="keyword">FUNCTION</span> notice_trigger()</span><br><span class="line">    show_notice_before_update_row BEFORE <span class="keyword">UPDATE</span> <span class="keyword">ON</span> example_table <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span> <span class="keyword">EXECUTE</span> <span class="keyword">FUNCTION</span> notice_trigger()</span><br><span class="line">    show_notice_before_update_stmt BEFORE <span class="keyword">UPDATE</span> <span class="keyword">ON</span> example_table <span class="keyword">FOR</span> <span class="keyword">EACH</span> STATEMENT <span class="keyword">EXECUTE</span> <span class="keyword">FUNCTION</span> notice_trigger()</span><br><span class="line">Partitions: example_table_1 <span class="keyword">FOR</span> <span class="keyword">VALUES</span> <span class="keyword">FROM</span> (<span class="number">0</span>) <span class="keyword">TO</span> (<span class="number">10</span>),</span><br><span class="line">            example_table_2 <span class="keyword">FOR</span> <span class="keyword">VALUES</span> <span class="keyword">FROM</span> (<span class="number">11</span>) <span class="keyword">TO</span> (<span class="number">20</span>),</span><br><span class="line">            example_table_3 <span class="keyword">FOR</span> <span class="keyword">VALUES</span> <span class="keyword">FROM</span> (<span class="number">21</span>) <span class="keyword">TO</span> (<span class="number">30</span>)</span><br></pre></td></tr></table></figure>
<p>分区表上也自动创建出了4个行级触发器。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">example<span class="operator">=</span># \d example_table_1</span><br><span class="line">          <span class="keyword">Table</span> &quot;public.example_table_1&quot;</span><br><span class="line"> <span class="keyword">Column</span> <span class="operator">|</span>  Type   <span class="operator">|</span> <span class="keyword">Collation</span> <span class="operator">|</span> Nullable <span class="operator">|</span> <span class="keyword">Default</span></span><br><span class="line"><span class="comment">--------+---------+-----------+----------+---------</span></span><br><span class="line"> col1   <span class="operator">|</span> <span class="type">integer</span> <span class="operator">|</span>           <span class="operator">|</span>          <span class="operator">|</span></span><br><span class="line"><span class="keyword">Partition</span> <span class="keyword">of</span>: example_table <span class="keyword">FOR</span> <span class="keyword">VALUES</span> <span class="keyword">FROM</span> (<span class="number">0</span>) <span class="keyword">TO</span> (<span class="number">10</span>)</span><br><span class="line">Triggers:</span><br><span class="line">    show_notice_after_insert_row AFTER <span class="keyword">INSERT</span> <span class="keyword">ON</span> example_table_1 <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span> <span class="keyword">EXECUTE</span> <span class="keyword">FUNCTION</span> notice_trigger(), <span class="keyword">ON</span> <span class="keyword">TABLE</span> example_table</span><br><span class="line">    show_notice_after_update_row AFTER <span class="keyword">UPDATE</span> <span class="keyword">ON</span> example_table_1 <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span> <span class="keyword">EXECUTE</span> <span class="keyword">FUNCTION</span> notice_trigger(), <span class="keyword">ON</span> <span class="keyword">TABLE</span> example_table</span><br><span class="line">    show_notice_before_insert_row BEFORE <span class="keyword">INSERT</span> <span class="keyword">ON</span> example_table_1 <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span> <span class="keyword">EXECUTE</span> <span class="keyword">FUNCTION</span> notice_trigger(), <span class="keyword">ON</span> <span class="keyword">TABLE</span> example_table</span><br><span class="line">    show_notice_before_update_row BEFORE <span class="keyword">UPDATE</span> <span class="keyword">ON</span> example_table_1 <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span> <span class="keyword">EXECUTE</span> <span class="keyword">FUNCTION</span> notice_trigger(), <span class="keyword">ON</span> <span class="keyword">TABLE</span> example_table</span><br></pre></td></tr></table></figure>
<p>分区表主表类型为（partitioned table)，分区表类型为（table）。</p>
<ul>
<li>在主表上创建触发器，会为每一个子表创建触发器。</li>
<li><code>FOR EACH STATEMENT</code> 只会在主表上创建</li>
<li><code>FOR EACH ROW</code> 才会为每一个子表创建（如下查询结果）。</li>
</ul>
<h4 id="插入一条数据"><a href="#插入一条数据" class="headerlink" title="插入一条数据"></a><strong>插入一条数据</strong></h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> example_table <span class="keyword">VALUES</span> (<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Output</span></span><br><span class="line">[<span class="number">00000</span>] <span class="keyword">trigger</span> name:show_notice_before_insert_stmt; table_name:example_table; level:STATEMENT; op:<span class="keyword">INSERT</span>; <span class="keyword">when</span>:BEFORE; <span class="keyword">value</span>:<span class="operator">&lt;</span><span class="keyword">NULL</span><span class="operator">&gt;</span></span><br><span class="line">[<span class="number">00000</span>] <span class="keyword">trigger</span> name:show_notice_before_insert_row; table_name:example_table_1; level:<span class="type">ROW</span>; op:<span class="keyword">INSERT</span>; <span class="keyword">when</span>:BEFORE; <span class="keyword">value</span>:(<span class="number">3</span>)</span><br><span class="line">[<span class="number">00000</span>] <span class="keyword">trigger</span> name:show_notice_after_insert_row; table_name:example_table_1; level:<span class="type">ROW</span>; op:<span class="keyword">INSERT</span>; <span class="keyword">when</span>:AFTER; <span class="keyword">value</span>:(<span class="number">3</span>)</span><br><span class="line">[<span class="number">00000</span>] <span class="keyword">trigger</span> name:show_notice_after_insert_stmt; table_name:example_table; level:STATEMENT; op:<span class="keyword">INSERT</span>; <span class="keyword">when</span>:AFTER; <span class="keyword">value</span>:<span class="operator">&lt;</span><span class="keyword">NULL</span><span class="operator">&gt;</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> affected <span class="keyword">in</span> <span class="number">60</span> ms</span><br></pre></td></tr></table></figure>
<p>分区表INSERT触发器的执行顺序：</p>
<ol>
<li>主表<code>example_table</code> statement 级别 INSERT BEFOER触发器</li>
<li>主表<code>example_table</code> statement 级别 INSERT AFTER 触发器</li>
<li>分区表<code>example_table_1</code> 行级别 INSERT BEFORE 触发器</li>
<li>分区表<code>example_table_1</code> 行级别 INSERT AFTER 触发器</li>
</ol>
<h4 id="插入不存在分区的数据"><a href="#插入不存在分区的数据" class="headerlink" title="插入不存在分区的数据"></a><strong>插入不存在分区的数据</strong></h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> example_table <span class="keyword">VALUES</span> (<span class="number">32</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Output</span></span><br><span class="line">[<span class="number">23514</span>] 错误: 没有为行找到关系&quot;example_table&quot;的分区</span><br><span class="line">详细：失败行的分区键包含(col1) <span class="operator">=</span> (<span class="number">32</span>).</span><br><span class="line">[<span class="number">00000</span>] <span class="keyword">trigger</span> name:show_notice_before_insert_stmt; table_name:example_table; level:STATEMENT; op:<span class="keyword">INSERT</span>; <span class="keyword">when</span>:BEFORE; <span class="keyword">value</span>:<span class="operator">&lt;</span><span class="keyword">NULL</span><span class="operator">&gt;</span></span><br></pre></td></tr></table></figure>
<p>插入一条不存在分区的数据时，会导致插入错误，提示没找到分区。分区表INSERT触发器的执行顺序：</p>
<ol>
<li>主表<code>example_table</code> statement 级别 INSERT BEFORE 触发器</li>
<li>主表<code>example_table</code> statement 级别 INSERT AFTER 触发器</li>
</ol>
<h4 id="修改触发器函数"><a href="#修改触发器函数" class="headerlink" title="修改触发器函数"></a>修改触发器函数</h4><p>修改触发器函数<code>notice_trigger</code>使它拥有创建表的能力。以下代码仅供测试，认为新插入数据时为不存在分区范围的数据，且分区列数值在31-40之间。并定义触发器在行级、插入前触发。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE <span class="keyword">FUNCTION</span> notice_trigger() <span class="keyword">RETURNS</span> <span class="keyword">TRIGGER</span> <span class="keyword">AS</span></span><br><span class="line">$$</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    RAISE NOTICE <span class="string">&#x27;trigger name:%; table_name:%; level:%; op:%; when:%; value:%&#x27;</span>,</span><br><span class="line">        tg_name, tg_table_name, tg_level, tg_op, tg_when, <span class="keyword">new</span>;</span><br><span class="line">    IF tg_level <span class="operator">=</span> <span class="string">&#x27;ROW&#x27;</span> <span class="keyword">AND</span> tg_op <span class="operator">=</span> <span class="string">&#x27;INSERT&#x27;</span> <span class="keyword">AND</span> tg_when <span class="operator">=</span> <span class="string">&#x27;BEFORE&#x27;</span> <span class="keyword">THEN</span></span><br><span class="line">        <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> example_table_4 <span class="keyword">PARTITION</span> <span class="keyword">OF</span> example_table <span class="keyword">FOR</span> <span class="keyword">VALUES</span> <span class="keyword">FROM</span> (<span class="number">31</span>) <span class="keyword">TO</span> (<span class="number">40</span>);</span><br><span class="line">        <span class="keyword">INSERT</span> <span class="keyword">INTO</span> example_table_4 <span class="keyword">SELECT</span> new.<span class="operator">*</span>;</span><br><span class="line">        <span class="keyword">RETURN</span> <span class="keyword">NULL</span>;</span><br><span class="line">    <span class="keyword">END</span> IF;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">RETURN</span> <span class="keyword">new</span>;</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line">$$ <span class="keyword">LANGUAGE</span> plpgsql;</span><br></pre></td></tr></table></figure>
<p>再次执行数据插入</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> example_table <span class="keyword">VALUES</span> (<span class="number">32</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Output</span></span><br><span class="line">[<span class="number">23514</span>] 错误: 没有为行找到关系&quot;example_table&quot;的分区</span><br><span class="line">详细：失败行的分区键包含(col1) <span class="operator">=</span> (<span class="number">32</span>).</span><br><span class="line">[<span class="number">00000</span>] <span class="keyword">trigger</span> name:show_notice_before_insert_stmt; table_name:example_table; level:STATEMENT; op:<span class="keyword">INSERT</span>; <span class="keyword">when</span>:BEFORE; <span class="keyword">value</span>:<span class="operator">&lt;</span><span class="keyword">NULL</span><span class="operator">&gt;</span></span><br></pre></td></tr></table></figure>
<p>主表上由于分区表的默认插入行为，并没有触发行级触发器，并由于自动路由，错误提示找不到关系分区报错退出。</p>
<h4 id="再次修改触发器函数"><a href="#再次修改触发器函数" class="headerlink" title="再次修改触发器函数"></a><strong>再次修改触发器函数</strong></h4><p>这次计划通过语句级别INSERT BEFORE触发器来创建新分区表。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE <span class="keyword">FUNCTION</span> notice_trigger() <span class="keyword">RETURNS</span> <span class="keyword">TRIGGER</span> <span class="keyword">AS</span></span><br><span class="line">$$</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    RAISE NOTICE <span class="string">&#x27;trigger name:%; table_name:%; level:%; op:%; when:%; value:%&#x27;</span>,</span><br><span class="line">        tg_name, tg_table_name, tg_level, tg_op, tg_when, <span class="keyword">new</span>;</span><br><span class="line">    IF tg_level <span class="operator">=</span> <span class="string">&#x27;STATEMENT&#x27;</span> <span class="keyword">AND</span> tg_op <span class="operator">=</span> <span class="string">&#x27;INSERT&#x27;</span> <span class="keyword">AND</span> tg_when <span class="operator">=</span> <span class="string">&#x27;BEFORE&#x27;</span> <span class="keyword">THEN</span></span><br><span class="line">        <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> example_table_4 <span class="keyword">PARTITION</span> <span class="keyword">OF</span> example_table <span class="keyword">FOR</span> <span class="keyword">VALUES</span> <span class="keyword">FROM</span> (<span class="number">31</span>) <span class="keyword">TO</span> (<span class="number">40</span>);</span><br><span class="line">        <span class="keyword">RETURN</span> <span class="keyword">NULL</span>;</span><br><span class="line">    <span class="keyword">END</span> IF;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">RETURN</span> <span class="keyword">new</span>;</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line">$$ <span class="keyword">LANGUAGE</span> plpgsql;</span><br></pre></td></tr></table></figure>
<p>再次尝试插入</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> example_table <span class="keyword">VALUES</span> (<span class="number">32</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Output</span></span><br><span class="line">[<span class="number">55006</span>] 错误: 无法<span class="keyword">CREATE</span> <span class="keyword">TABLE</span> .. <span class="keyword">PARTITION</span> <span class="keyword">OF</span> &quot;example_table&quot;  因为它正在被这个会话中的活动查询使用</span><br><span class="line">在位置：<span class="keyword">SQL</span> 语句 &quot;CREATE TABLE example_table_4 PARTITION OF example_table FOR VALUES FROM (31) TO (40)&quot;</span><br><span class="line">在<span class="keyword">SQL</span>语句的第<span class="number">6</span>行的PL<span class="operator">/</span>pgSQL函数notice_trigger()</span><br><span class="line">[<span class="number">00000</span>] <span class="keyword">trigger</span> name:show_notice_before_insert_stmt; table_name:example_table; level:STATEMENT; op:<span class="keyword">INSERT</span>; <span class="keyword">when</span>:BEFORE; <span class="keyword">value</span>:<span class="operator">&lt;</span><span class="keyword">NULL</span><span class="operator">&gt;</span></span><br></pre></td></tr></table></figure>
<p>从上得知，<strong><code>BEFORE ROW</code> 触发器无法更改哪个分区是新行的最终目标。</strong></p>
<h3 id="自动路由流程"><a href="#自动路由流程" class="headerlink" title="自动路由流程"></a>自动路由流程</h3><p>从以上动作得知：</p>
<ul>
<li>分区表主表只会触发语句级别的触发器</li>
<li>分区表只会触发行级触发器</li>
<li>数据库会对插入和更新动作自动做路由规则处理</li>
</ul>
<p><img src="../../public/images/分区表pg处理流程.png" alt="自动路由处理流程"></p>
<p>整个插入过程在一个事务内，在插入开始期间，会收集整个分区表信息；声明式分区表有一个内置的路由行为，该行为发生在语句级别before触发器之后。它会根据分区列将实际的INSERT/UPDATE动作定向到分区中进行插入和更新。此时主分区表不会触发它的行级触发器，而是触发分区表中的行级触发器，且不会触发分区表的语句级触发器。无法在语句级别动态创建新分区，到达自动路由阶段，对不存在分区的插入会导致插入失败，不再执行后续动作。</p>
<h1 id="规则系统"><a href="#规则系统" class="headerlink" title="规则系统"></a>规则系统</h1><p>考虑到高可维护性，简便易行和最大程度使用数据库的特点，最终考虑使用声明式分区来实现自动表分区。</p>
<p>既然无法使用触发器达到在插入数据时，自动创建不存在范围的分区表的行为，有没有办法不通过触发器，而通过数据库自身的特性达到同样的目的呢？</p>
<p>答案是有的。经过调研，PostgreSQL数据库支持重写规则（RULE）。</p>
<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [ <span class="keyword">OR</span> REPLACE ] RULE name <span class="keyword">AS</span> <span class="keyword">ON</span> event</span><br><span class="line">    <span class="keyword">TO</span> table_name [ <span class="keyword">WHERE</span> <span class="keyword">condition</span> ]</span><br><span class="line">    DO [ ALSO <span class="operator">|</span> INSTEAD ] &#123; NOTHING <span class="operator">|</span> command <span class="operator">|</span> ( command ; command ... ) &#125;</span><br><span class="line"></span><br><span class="line">其中 event 可以是以下之一：</span><br><span class="line"></span><br><span class="line">    <span class="keyword">SELECT</span> <span class="operator">|</span> <span class="keyword">INSERT</span> <span class="operator">|</span> <span class="keyword">UPDATE</span> <span class="operator">|</span> <span class="keyword">DELETE</span></span><br></pre></td></tr></table></figure>
<p>PostgreSQL规则系统允许我们定义   针对数据库表中插入、更新或者删除动作上的替代动作。大约来说，当在   一个给定表上执行给定命令时，一条规则会导致执行额外的命令。或者，   <code>INSTEAD</code>规则可以用另一个命令替换给定的命令，或者导致一个命令根本不被执行。</p>
<p>使用规则来改变插入的流程，绕开分区表触发器的执行顺序限制，直接插入到目标表内。</p>
<p>原理是使用规则重定向插入，将INSERT/UPDATE操作替换成用函数来插入。函数插入时判断是否报错了，如果报错，新增表。</p>
<h2 id="设计流程"><a href="#设计流程" class="headerlink" title="设计流程"></a>设计流程</h2><p>在分区表主表上创建两个规则，分别是INSERT和 UPDATE，替换数据库向主表默认插入和更新操作。此时的触发器和流程从下图左边变成了右边的流程，规则接管默认插入机制，在插入数据前做一层条件判断，达到自动创建分区的目的。由于规则系统仅支持INSERT/UPDATE/SELECT/DELETE操作，因此需要编写一个函数来托管整个过程。</p>
<p><img src="../../public/images/分区表pg处理流程2.png" alt="重写规则"></p>
<p>在这个大框架下还需要解决自动化创建表时一致性行为，以及接管一些数据库默认插入/更新时的功能：</p>
<ul>
<li>表分区名称约定</li>
<li>结合Filecoin业务，比如根据区块高度对数据分区，对高度计算得到分区表后缀</li>
<li>获取分区表名称是否存在</li>
<li>唯一键冲突</li>
<li>分区移动</li>
</ul>
<h1 id="函数-存储过程"><a href="#函数-存储过程" class="headerlink" title="函数(存储过程)"></a>函数(存储过程)</h1><h2 id="表分区名称约定"><a href="#表分区名称约定" class="headerlink" title="表分区名称约定"></a>表分区名称约定</h2><h3 id="表名称约定"><a href="#表名称约定" class="headerlink" title="表名称约定"></a>表名称约定</h3><p>通常，对表的数据进行分区，对数据行记录时间进行划分。以此为基础便于以时间范围查询，因此分区表将设置成主表+后缀名的方式命名。后缀名定义以下4种按时间划分的分区规则：</p>
<ol>
<li>按天分区 (分区表命名规则：<code>table_name_2022_02_18_1560240_1563119</code>)</li>
<li>按周分区 (分区表命名规则：<code>table_name_2022_w7_1548720_1568879</code>)</li>
<li>按月分区 (分区表命名规则：<code>table_name_2022_02_1560240_1563119</code>)</li>
<li>按年分区 (分区表命名规则：<code>table_name_2022_1560240_1563119</code>)</li>
</ol>
<p>以上分区规则统一按照北京时间为基准，以一天的零点作为开始，23点59分59秒作为结束。</p>
<p><strong>按天分区</strong></p>
<p>分区表命名规则为 <code>主表</code>_<code>年</code>_<code>月</code>_<code>日</code>_<code>起始epoch</code>_<code>终止epoch</code></p>
<p>其中月份为两位数，不足两位前缀补0。</p>
<p><strong>按周分区</strong></p>
<p>分区表命名规则为 <code>主表</code>_<code>年</code>_<code>w全年周数</code>_<code>起始epoch</code>_<code>终止epoch</code></p>
<p><strong>按月分区</strong></p>
<p>分区表命名规则为 <code>主表</code>_<code>年</code>_<code>月</code>_<code>起始epoch</code>_<code>终止epoch</code></p>
<p>其中月份为两位数，不足两位前缀补0。</p>
<p><strong>按年分区</strong></p>
<p>分区表命名规则为 <code>主表</code>_<code>年</code>_<code>起始epoch</code>_<code>终止epoch</code></p>
<p><strong>以下内容为实现分区表命名规则而设立的函数，执行函数可以计算得到上述规则后缀和分区范围。</strong></p>
<h3 id="分区范围类型定义"><a href="#分区范围类型定义" class="headerlink" title="分区范围类型定义"></a>分区范围类型定义</h3><p>定义数据库的类型，拥有以下6个字段：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> TYPE IF <span class="keyword">EXISTS</span> PARTITION_TABLE_RANGE_DEFINITION CASCADE ;</span><br><span class="line"><span class="comment">-- 创建统一的分区规则类型，定义后缀字段、触发查询时的日期、</span></span><br><span class="line"><span class="comment">-- 分区的起始时间(起始epoch)和终止时间(终止epoch)</span></span><br><span class="line"><span class="comment">-- 终止epoch与终止时间不是一一对应，终止epoch通常是23:59:30。链的高度每30秒变更一次。</span></span><br><span class="line"><span class="keyword">CREATE</span> TYPE PARTITION_TABLE_RANGE_DEFINITION <span class="keyword">AS</span></span><br><span class="line">(</span><br><span class="line">    suffix      <span class="type">VARCHAR</span>,</span><br><span class="line">    hit_date    <span class="type">DATE</span>,</span><br><span class="line">    begin_epoch <span class="type">BIGINT</span>,</span><br><span class="line">    begin_time  TIMESTAMPTZ,</span><br><span class="line">    end_epoch   <span class="type">BIGINT</span>,</span><br><span class="line">    end_time    TIMESTAMPTZ</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th>分区范围字段</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>suffix</td>
<td>分区表的后缀名称，配合主表名+后缀定义出分区表名称</td>
</tr>
<tr>
<td>hit_date</td>
<td>查询分区范围定义的日期</td>
</tr>
<tr>
<td>begin_epoch</td>
<td>分区表开始高度（Filecoin epoch， 下同)</td>
</tr>
<tr>
<td>begin_time</td>
<td>分区表开始时间（参考，分区以begin_epoch为主，下同）</td>
</tr>
<tr>
<td>end_epoch</td>
<td>分区表结束高度</td>
</tr>
<tr>
<td>end_time</td>
<td>分区表结束时间</td>
</tr>
</tbody>
</table>
</div>
<h3 id="分区范围实现"><a href="#分区范围实现" class="headerlink" title="分区范围实现"></a>分区范围实现</h3><p>注意！分区表<code>FROM (MINVALUE) TO (101)</code> 是前闭后开。也就是插入的分区列应满足 epoch ∈[MINVALUE, 101)</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test_part_table(col1 <span class="type">INT</span>) <span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">RANGE</span> (col1);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test_part_table_1 <span class="keyword">PARTITION</span> <span class="keyword">OF</span> test_part_table <span class="keyword">FOR</span> <span class="keyword">VALUES</span> <span class="keyword">FROM</span> (<span class="number">0</span>) <span class="keyword">TO</span> (<span class="number">10</span>);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test_part_table_2 <span class="keyword">PARTITION</span> <span class="keyword">OF</span> test_part_table <span class="keyword">FOR</span> <span class="keyword">VALUES</span> <span class="keyword">FROM</span> (<span class="number">10</span>) <span class="keyword">TO</span> (<span class="number">20</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_part_table <span class="keyword">SELECT</span> i <span class="keyword">FROM</span> generate_series(<span class="number">0</span>, <span class="number">10</span>) g(i);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入到 test_part_table_1 的值 从 0-9；</span></span><br><span class="line"><span class="comment">-- 插入到 test_part_table_2 的值 为10.</span></span><br></pre></td></tr></table></figure>
<h4 id="按天分区"><a href="#按天分区" class="headerlink" title="按天分区"></a>按天分区</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 按日分区，返回的分区表的表后缀规则为 &#x27;年_月_日&#x27;_开始epoch_结束epoch </span></span><br><span class="line"><span class="comment">-- (例如：table_name_2022_02_18_1560240_1563119)</span></span><br><span class="line"><span class="comment">-- 时间范围 一天的的00:00:00 ~ 一天的23:59:59</span></span><br><span class="line"><span class="comment">-- 高度范围 一天日期的00:00:00 ~ 一天日期的23:59:30</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE <span class="keyword">FUNCTION</span> calc_partition_range_by_day(current_ts TIMESTAMPTZ <span class="operator">=</span> <span class="built_in">current_timestamp</span>)</span><br><span class="line">    <span class="keyword">RETURNS</span> SETOF PARTITION_TABLE_RANGE_DEFINITION</span><br><span class="line">    IMMUTABLE STRICT</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line">$$</span><br><span class="line"><span class="keyword">DECLARE</span></span><br><span class="line">    startup_time timestamptz <span class="operator">=</span> <span class="string">&#x27;2020-08-25T06:00:00+08:00&#x27;</span>::timestamptz;</span><br><span class="line">    &quot;year&quot;       <span class="type">INT</span>         <span class="operator">=</span> <span class="built_in">extract</span>(<span class="keyword">YEAR</span> <span class="keyword">FROM</span> current_ts);</span><br><span class="line">    &quot;month&quot;      <span class="type">INT</span>         <span class="operator">=</span> <span class="built_in">extract</span>(MONTHS <span class="keyword">FROM</span> current_ts);</span><br><span class="line">    &quot;day&quot;        <span class="type">INT</span>         <span class="operator">=</span> <span class="built_in">extract</span>(<span class="keyword">DAY</span> <span class="keyword">FROM</span> current_ts);</span><br><span class="line">    begin_time   TIMESTAMPTZ <span class="operator">=</span> date_trunc(<span class="string">&#x27;day&#x27;</span>, current_ts);</span><br><span class="line">    begin_epoch  <span class="type">BIGINT</span>      <span class="operator">=</span> calc_epoch_by_ts(begin_time);</span><br><span class="line">    day_interval <span class="type">INTERVAL</span>    <span class="operator">=</span> <span class="type">INTERVAL</span> <span class="string">&#x27;1 DAY&#x27;</span> <span class="operator">-</span> <span class="type">INTERVAL</span> <span class="string">&#x27;1 SECOND&#x27;</span>;</span><br><span class="line">    end_time     TIMESTAMPTZ <span class="operator">=</span> begin_time <span class="operator">+</span> day_interval;</span><br><span class="line">    end_epoch    <span class="type">BIGINT</span>      <span class="operator">=</span> calc_epoch_by_ts(end_time <span class="operator">+</span> <span class="type">INTERVAL</span> <span class="string">&#x27;1 SECOND&#x27;</span>);</span><br><span class="line">    mm_month     <span class="type">VARCHAR</span>     <span class="operator">=</span> (<span class="keyword">CASE</span> <span class="keyword">WHEN</span> &quot;month&quot; <span class="operator">&lt;</span> <span class="number">10</span> <span class="keyword">THEN</span> <span class="string">&#x27;0&#x27;</span> <span class="operator">||</span> &quot;month&quot; <span class="keyword">ELSE</span> <span class="string">&#x27;&#x27;</span> <span class="operator">||</span> &quot;month&quot; <span class="keyword">END</span>);</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="comment">--     考虑边界条件，当计算得出的起始高度小于0，说明时间已经小于主网上线时间。</span></span><br><span class="line">    IF begin_epoch <span class="operator">&lt;</span> <span class="number">0</span> <span class="keyword">THEN</span></span><br><span class="line">        begin_time <span class="operator">=</span> startup_time;</span><br><span class="line">        begin_epoch <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        &quot;year&quot; <span class="operator">=</span> <span class="built_in">extract</span>(<span class="keyword">YEAR</span> <span class="keyword">FROM</span> begin_time);</span><br><span class="line">        &quot;month&quot; <span class="operator">=</span> <span class="built_in">extract</span>(MONTHS <span class="keyword">FROM</span> begin_time);</span><br><span class="line">        &quot;day&quot; <span class="operator">=</span> <span class="built_in">extract</span>(<span class="keyword">DAY</span> <span class="keyword">FROM</span> begin_time);</span><br><span class="line">        end_time <span class="operator">=</span> date_trunc(<span class="string">&#x27;day&#x27;</span>, begin_time) <span class="operator">+</span> day_interval;</span><br><span class="line">        end_epoch <span class="operator">=</span> calc_epoch_by_ts(end_time <span class="operator">+</span> <span class="type">INTERVAL</span> <span class="string">&#x27;1 SECOND&#x27;</span>);</span><br><span class="line">        mm_month <span class="operator">=</span> (<span class="keyword">CASE</span> <span class="keyword">WHEN</span> &quot;month&quot; <span class="operator">&lt;</span> <span class="number">10</span> <span class="keyword">THEN</span> <span class="string">&#x27;0&#x27;</span> <span class="operator">||</span> &quot;month&quot; <span class="keyword">ELSE</span> <span class="string">&#x27;&#x27;</span> <span class="operator">||</span> &quot;month&quot; <span class="keyword">END</span>);</span><br><span class="line">    <span class="keyword">END</span> IF;</span><br><span class="line">    RAISE NOTICE <span class="string">&#x27;[calc_partition_range_by_day]current_ts: %&#x27;</span>, current_ts;</span><br><span class="line">    <span class="keyword">RETURN</span> QUERY <span class="keyword">SELECT</span> concat_ws(<span class="string">&#x27;_&#x27;</span>, &quot;year&quot;, mm_month, &quot;day&quot;, begin_epoch, end_epoch)::<span class="type">VARCHAR</span>,</span><br><span class="line">                        current_ts::<span class="type">DATE</span>,</span><br><span class="line">                        begin_epoch,</span><br><span class="line">                        begin_time,</span><br><span class="line">                        end_epoch,</span><br><span class="line">                        end_time;</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line">$$ <span class="keyword">LANGUAGE</span> plpgsql;</span><br></pre></td></tr></table></figure>
<h4 id="按周分区"><a href="#按周分区" class="headerlink" title="按周分区"></a>按周分区</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 按周分区，返回的分区表的表后缀规则为 &#x27;年份&#x27;_w&#x27;第n周&#x27;_开始epoch_结束epoch </span></span><br><span class="line"><span class="comment">-- (例如：table_name_2022_w7_1548720_1568879)</span></span><br><span class="line"><span class="comment">-- 时间范围 周一的00:00:00 ~ 周日的23:59:59</span></span><br><span class="line"><span class="comment">-- 高度范围 周一日期的00:00:00 ~ 周日的23:59:30</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE <span class="keyword">FUNCTION</span> calc_partition_range_by_week_of_year(current_ts TIMESTAMPTZ <span class="operator">=</span> <span class="built_in">current_timestamp</span>)</span><br><span class="line">    <span class="keyword">RETURNS</span> SETOF PARTITION_TABLE_RANGE_DEFINITION</span><br><span class="line">    IMMUTABLE STRICT</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line">$$</span><br><span class="line"><span class="keyword">DECLARE</span></span><br><span class="line">    startup_time timestamptz <span class="operator">=</span> <span class="string">&#x27;2020-08-25T06:00:00+08:00&#x27;</span>::timestamptz;</span><br><span class="line">    week_of_year  <span class="type">INT</span>         <span class="operator">=</span> <span class="built_in">extract</span>(WEEK <span class="keyword">FROM</span> current_ts);</span><br><span class="line">    iso_year      <span class="type">INT</span>         <span class="operator">=</span> <span class="built_in">extract</span>(ISOYEAR <span class="keyword">FROM</span> current_ts);</span><br><span class="line">    begin_of_week TIMESTAMPTZ <span class="operator">=</span> date_trunc(<span class="string">&#x27;WEEK&#x27;</span>, current_ts);</span><br><span class="line">    begin_epoch   <span class="type">BIGINT</span>      <span class="operator">=</span> calc_epoch_by_ts(begin_of_week);</span><br><span class="line">    week_interval <span class="type">INTERVAL</span>    <span class="operator">=</span> <span class="type">INTERVAL</span> <span class="string">&#x27;7 DAYS&#x27;</span>;</span><br><span class="line">    end_of_week   TIMESTAMPTZ <span class="operator">=</span> begin_of_week <span class="operator">+</span> week_interval;</span><br><span class="line">    end_epoch     <span class="type">BIGINT</span>      <span class="operator">=</span> calc_epoch_by_ts(end_of_week);</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="comment">--     考虑边界条件，当计算得出的起始高度小于0，说明时间已经小于主网上线时间。</span></span><br><span class="line">    IF begin_epoch <span class="operator">&lt;</span> <span class="number">0</span> <span class="keyword">THEN</span></span><br><span class="line">        begin_of_week <span class="operator">=</span> startup_time;</span><br><span class="line">        begin_epoch <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        week_of_year <span class="operator">=</span> <span class="built_in">extract</span>(WEEK <span class="keyword">FROM</span> begin_of_week);</span><br><span class="line">        iso_year <span class="operator">=</span> <span class="built_in">extract</span>(ISOYEAR <span class="keyword">FROM</span> begin_of_week);</span><br><span class="line">        end_of_week <span class="operator">=</span> date_trunc(<span class="string">&#x27;WEEK&#x27;</span>, begin_of_week) <span class="operator">+</span> week_interval;</span><br><span class="line">        end_epoch <span class="operator">=</span> calc_epoch_by_ts(end_of_week);</span><br><span class="line">    <span class="keyword">END</span> IF;</span><br><span class="line">    <span class="keyword">RETURN</span> QUERY <span class="keyword">SELECT</span> (concat_ws(<span class="string">&#x27;_&#x27;</span>, iso_year, concat(<span class="string">&#x27;w&#x27;</span>, week_of_year), begin_epoch, end_epoch))::<span class="type">VARCHAR</span>,</span><br><span class="line">                        current_ts::<span class="type">DATE</span>,</span><br><span class="line">                        begin_epoch,</span><br><span class="line">                        begin_of_week,</span><br><span class="line">                        end_epoch,</span><br><span class="line">                        end_of_week;</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line">$$ <span class="keyword">LANGUAGE</span> plpgsql;</span><br></pre></td></tr></table></figure>
<h4 id="按月分区"><a href="#按月分区" class="headerlink" title="按月分区"></a>按月分区</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 按月分区，返回的分区表的表后缀规则为 &#x27;年_月&#x27;_开始epoch_结束epoch </span></span><br><span class="line"><span class="comment">-- (例如：table_name_2022_02_1560240_1563119)</span></span><br><span class="line"><span class="comment">-- 时间范围 每个月的第一天的的00:00:00 ~ 每个月的最后一天的23:59:59</span></span><br><span class="line"><span class="comment">-- 高度范围 每个月的第一天日期的00:00:00 ~ 每个月的最后一天日期的23:59:30</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE <span class="keyword">FUNCTION</span> calc_partition_range_by_month(current_ts TIMESTAMPTZ <span class="operator">=</span> <span class="built_in">current_timestamp</span>)</span><br><span class="line">    <span class="keyword">RETURNS</span> SETOF PARTITION_TABLE_RANGE_DEFINITION</span><br><span class="line">    IMMUTABLE STRICT</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line">$$</span><br><span class="line"><span class="keyword">DECLARE</span></span><br><span class="line">    startup_time timestamptz <span class="operator">=</span> <span class="string">&#x27;2020-08-25T06:00:00+08:00&#x27;</span>::timestamptz;</span><br><span class="line">    begin_time     TIMESTAMPTZ <span class="operator">=</span> date_trunc(<span class="string">&#x27;month&#x27;</span>, current_ts);</span><br><span class="line">    &quot;year&quot;         <span class="type">INT</span>         <span class="operator">=</span> <span class="built_in">extract</span>(<span class="keyword">YEAR</span> <span class="keyword">FROM</span> begin_time);</span><br><span class="line">    &quot;month&quot;        <span class="type">INT</span>         <span class="operator">=</span> <span class="built_in">extract</span>(MONTHS <span class="keyword">FROM</span> begin_time);</span><br><span class="line">    begin_epoch    <span class="type">BIGINT</span>      <span class="operator">=</span> calc_epoch_by_ts(begin_time);</span><br><span class="line">    month_interval <span class="type">INTERVAL</span>    <span class="operator">=</span> <span class="type">INTERVAL</span> <span class="string">&#x27;1 month&#x27;</span>;</span><br><span class="line">    end_time       TIMESTAMPTZ <span class="operator">=</span> begin_time <span class="operator">+</span> month_interval;</span><br><span class="line">    end_epoch      <span class="type">BIGINT</span>      <span class="operator">=</span> calc_epoch_by_ts(end_time);</span><br><span class="line">    mm_month       <span class="type">VARCHAR</span>     <span class="operator">=</span> (<span class="keyword">CASE</span> <span class="keyword">WHEN</span> &quot;month&quot; <span class="operator">&lt;</span> <span class="number">10</span> <span class="keyword">THEN</span> <span class="string">&#x27;0&#x27;</span> <span class="operator">||</span> &quot;month&quot; <span class="keyword">ELSE</span> <span class="string">&#x27;&#x27;</span> <span class="operator">||</span> &quot;month&quot; <span class="keyword">END</span>);</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="comment">--     考虑边界条件，当计算得出的起始高度小于0，说明时间已经小于主网上线时间。</span></span><br><span class="line">    IF begin_epoch <span class="operator">&lt;</span> <span class="number">0</span> <span class="keyword">THEN</span></span><br><span class="line">        begin_time <span class="operator">=</span> startup_time;</span><br><span class="line">        begin_epoch <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        &quot;year&quot; <span class="operator">=</span> <span class="built_in">extract</span>(<span class="keyword">YEAR</span> <span class="keyword">FROM</span> begin_time);</span><br><span class="line">        &quot;month&quot; <span class="operator">=</span> <span class="built_in">extract</span>(MONTHS <span class="keyword">FROM</span> begin_time);</span><br><span class="line">        end_time <span class="operator">=</span> date_trunc(<span class="string">&#x27;month&#x27;</span>, begin_time) <span class="operator">+</span> month_interval;</span><br><span class="line">        end_epoch <span class="operator">=</span> calc_epoch_by_ts(end_time);</span><br><span class="line">        mm_month <span class="operator">=</span> (<span class="keyword">CASE</span> <span class="keyword">WHEN</span> &quot;month&quot; <span class="operator">&lt;</span> <span class="number">10</span> <span class="keyword">THEN</span> <span class="string">&#x27;0&#x27;</span> <span class="operator">||</span> &quot;month&quot; <span class="keyword">ELSE</span> <span class="string">&#x27;&#x27;</span> <span class="operator">||</span> &quot;month&quot; <span class="keyword">END</span>)::<span class="type">varchar</span>;</span><br><span class="line">    <span class="keyword">END</span> IF;</span><br><span class="line">    <span class="keyword">RETURN</span> QUERY <span class="keyword">SELECT</span> (concat_ws(<span class="string">&#x27;_&#x27;</span>, &quot;year&quot;, mm_month, begin_epoch, end_epoch))::<span class="type">VARCHAR</span>,</span><br><span class="line">                        current_ts::<span class="type">DATE</span>,</span><br><span class="line">                        begin_epoch,</span><br><span class="line">                        begin_time,</span><br><span class="line">                        end_epoch,</span><br><span class="line">                        end_time;</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line">$$ <span class="keyword">LANGUAGE</span> plpgsql;</span><br></pre></td></tr></table></figure>
<h4 id="按年分区"><a href="#按年分区" class="headerlink" title="按年分区"></a>按年分区</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 按年分区，返回的分区表的表后缀规则为 &#x27;年&#x27;_开始epoch_结束epoch </span></span><br><span class="line"><span class="comment">-- (例如：table_name_2022_1560240_1563119)</span></span><br><span class="line"><span class="comment">-- 时间范围 每年的第一天的的00:00:00 ~ 每年的最后一天的23:59:59</span></span><br><span class="line"><span class="comment">-- 高度范围 每年的第一天日期的00:00:00 ~ 每年的最后一天日期的23:59:30</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE <span class="keyword">FUNCTION</span> calc_partition_range_by_year(current_ts TIMESTAMPTZ <span class="operator">=</span> <span class="built_in">current_timestamp</span>)</span><br><span class="line">    <span class="keyword">RETURNS</span> SETOF PARTITION_TABLE_RANGE_DEFINITION</span><br><span class="line">    IMMUTABLE STRICT</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line">$$</span><br><span class="line"><span class="keyword">DECLARE</span></span><br><span class="line">    startup_time timestamptz <span class="operator">=</span> <span class="string">&#x27;2020-08-25T06:00:00+08:00&#x27;</span>::timestamptz;</span><br><span class="line">    first_day_of_year TIMESTAMPTZ <span class="operator">=</span> date_trunc(<span class="string">&#x27;year&#x27;</span>, current_ts);</span><br><span class="line">    year_interval     <span class="type">INTERVAL</span>    <span class="operator">=</span> <span class="type">INTERVAL</span> <span class="string">&#x27;1 year&#x27;</span>;</span><br><span class="line">    last_day_of_year  TIMESTAMPTZ <span class="operator">=</span> first_day_of_year <span class="operator">+</span> year_interval;</span><br><span class="line">    begin_epoch       <span class="type">BIGINT</span>      <span class="operator">=</span> calc_epoch_by_ts(first_day_of_year);</span><br><span class="line">    end_epoch         <span class="type">BIGINT</span>      <span class="operator">=</span> calc_epoch_by_ts(last_day_of_year);</span><br><span class="line">    &quot;year&quot;            <span class="type">INT</span>         <span class="operator">=</span> <span class="built_in">extract</span>(<span class="keyword">YEAR</span> <span class="keyword">FROM</span> first_day_of_year);</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="comment">--     考虑边界条件，当计算得出的起始高度小于0，说明时间已经小于主网上线时间。</span></span><br><span class="line">    IF begin_epoch <span class="operator">&lt;</span> <span class="number">0</span> <span class="keyword">THEN</span></span><br><span class="line">        first_day_of_year <span class="operator">=</span> startup_time;</span><br><span class="line">        begin_epoch <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        last_day_of_year <span class="operator">=</span> date_trunc(<span class="string">&#x27;year&#x27;</span>, first_day_of_year) <span class="operator">+</span> year_interval;</span><br><span class="line">        end_epoch <span class="operator">=</span> calc_epoch_by_ts(last_day_of_year);</span><br><span class="line">        &quot;year&quot; <span class="operator">=</span> <span class="built_in">extract</span>(<span class="keyword">YEAR</span> <span class="keyword">FROM</span> first_day_of_year);</span><br><span class="line">    <span class="keyword">END</span> IF;</span><br><span class="line">    <span class="keyword">RETURN</span> QUERY <span class="keyword">SELECT</span> (concat_ws(<span class="string">&#x27;_&#x27;</span>, &quot;year&quot;, begin_epoch, end_epoch))::<span class="type">VARCHAR</span>,</span><br><span class="line">                        current_ts::<span class="type">DATE</span>,</span><br><span class="line">                        begin_epoch,</span><br><span class="line">                        first_day_of_year,</span><br><span class="line">                        end_epoch,</span><br><span class="line">                        last_day_of_year;</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line">$$ <span class="keyword">LANGUAGE</span> plpgsql;</span><br></pre></td></tr></table></figure>
<h2 id="区块高度与时间"><a href="#区块高度与时间" class="headerlink" title="区块高度与时间"></a>区块高度与时间</h2><p>2020-08-25T06:00:00+08:00 是Filecoin 上线时间，每30秒一个纪元（高度）。通过与上线时间与高度换算的相对秒数，求得高度对应的时间。反之亦然。其计算方式如下：</p>
<h3 id="高度转换时间"><a href="#高度转换时间" class="headerlink" title="高度转换时间"></a>高度转换时间</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 根据当前时间计算出对应的FileCoin高度，如果不传高度，默认高度为0，即链的起始高度。</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE <span class="keyword">FUNCTION</span> calc_timestamp_by_epoch(height <span class="type">BIGINT</span> <span class="operator">=</span> <span class="number">0</span>) <span class="keyword">RETURNS</span> <span class="type">TIMESTAMP</span> <span class="keyword">WITH</span> <span class="type">TIME</span> ZONE</span><br><span class="line">    IMMUTABLE STRICT</span><br><span class="line">    <span class="keyword">LANGUAGE</span> plpgsql</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line">$$</span><br><span class="line"><span class="keyword">DECLARE</span></span><br><span class="line">    baseEpoch <span class="type">INTEGER</span> <span class="operator">=</span> <span class="built_in">extract</span>(EPOCH <span class="keyword">FROM</span> TIMESTAMPTZ <span class="string">&#x27;2020-08-25T06:00:00+08:00&#x27;</span>)::<span class="type">INTEGER</span>;</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="comment">-- 根据高度计算时间</span></span><br><span class="line">    <span class="keyword">RETURN</span> to_timestamp(baseEpoch <span class="operator">+</span> height <span class="operator">*</span> <span class="number">30</span>);</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line">$$;</span><br></pre></td></tr></table></figure>
<h3 id="时间转换高度"><a href="#时间转换高度" class="headerlink" title="时间转换高度"></a>时间转换高度</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 根据FileCoin epoch计算出对应的时间，传入的参数如不填，默认当前时间</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE <span class="keyword">FUNCTION</span> calc_epoch_by_ts(ts <span class="type">timestamp</span> <span class="keyword">with</span> <span class="type">time</span> zone <span class="operator">=</span> <span class="built_in">current_timestamp</span>) <span class="keyword">RETURNS</span> <span class="type">bigint</span></span><br><span class="line">    IMMUTABLE STRICT</span><br><span class="line">    <span class="keyword">LANGUAGE</span> plpgsql</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line">$$</span><br><span class="line"><span class="keyword">DECLARE</span></span><br><span class="line">    baseTime <span class="type">TIMESTAMP</span> <span class="operator">=</span> TIMESTAMPTZ <span class="string">&#x27;2020-08-25T06:00:00+08:00&#x27;</span>;</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="comment">-- 根据时间计算高度</span></span><br><span class="line">    <span class="keyword">RETURN</span> <span class="built_in">extract</span>(EPOCH <span class="keyword">FROM</span> (ts <span class="operator">-</span> baseTime))::<span class="type">INTEGER</span> <span class="operator">/</span> <span class="number">30</span>;</span><br><span class="line"><span class="keyword">END</span> </span><br><span class="line">$$;</span><br></pre></td></tr></table></figure>
<h2 id="获取分区名称"><a href="#获取分区名称" class="headerlink" title="获取分区名称"></a>获取分区名称</h2><p>通过系统数据库(pg_catalog)中的表获得分区表名称。如果不存在分区表，返回NULL。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE <span class="keyword">FUNCTION</span></span><br><span class="line">    pg_get_part_table_name(main_table <span class="type">VARCHAR</span>, suffix <span class="type">VARCHAR</span>)</span><br><span class="line">    <span class="keyword">RETURNS</span> <span class="type">VARCHAR</span></span><br><span class="line">    IMMUTABLE</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line">$$</span><br><span class="line"><span class="keyword">DECLARE</span></span><br><span class="line">    part_table_name <span class="type">VARCHAR</span>;</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">WITH</span> o <span class="keyword">AS</span> (<span class="keyword">SELECT</span> inhrelid <span class="keyword">FROM</span> pg_inherits <span class="keyword">WHERE</span> inhparent <span class="operator">=</span> (concat_ws(<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;public&#x27;</span>, main_table))::REGCLASS)</span><br><span class="line">    <span class="keyword">SELECT</span> relname</span><br><span class="line">    <span class="keyword">FROM</span> pg_class</span><br><span class="line">    <span class="keyword">WHERE</span> oid <span class="keyword">IN</span> (<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> o)</span><br><span class="line">      <span class="keyword">AND</span> relname <span class="operator">=</span> concat_ws(<span class="string">&#x27;_&#x27;</span>, main_table, suffix)</span><br><span class="line">    <span class="keyword">INTO</span> part_table_name;</span><br><span class="line">    <span class="keyword">RETURN</span> part_table_name;</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line">$$ <span class="keyword">LANGUAGE</span> plpgsql;</span><br></pre></td></tr></table></figure>
<h2 id="获取分区表分区键（废弃⚠️-at-2022-03-25）"><a href="#获取分区表分区键（废弃⚠️-at-2022-03-25）" class="headerlink" title="获取分区表分区键（废弃⚠️ at 2022-03-25）"></a>获取分区表分区键（废弃⚠️ at 2022-03-25）</h2><p><strong>这个函数用来插入时作为更新键，但实际作为更新键通常是唯一键。唯一键可以是复合键。该函数不适用。</strong></p>
<p><code>pg_get_partkeydef</code> PostgreSQL 内置函数，位于<code>pg_catalog</code> 数据库中，用于提取分区表的分区键定义。<code>strpos</code>和<code>substr</code>函数同样位于<code>pg_catalog</code>数据库中定义，这两个函数参数用法与C语言相同。</p>
<p>通过<code>pg_get_partkeydef</code>函数返回的结果如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> pg_get_partkeydef(<span class="string">&#x27;test&#x27;</span>::regclass);</span><br><span class="line"><span class="comment">-- Output: RANGE (epoch)</span></span><br></pre></td></tr></table></figure>
<p>使用<code>strpos</code>和<code>substr</code>得到上述返回结果定义列名称。完整实现如下：</p>
<p>通过调用<code>pg_get_part_table_range_key</code> 输入分区表（主表）名称转换成oid，返回分区键名称。非分区表返回结果为NULL。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE <span class="keyword">FUNCTION</span> pg_get_part_table_range_key(oid REGCLASS)</span><br><span class="line">    <span class="keyword">RETURNS</span> <span class="type">VARCHAR</span></span><br><span class="line">    IMMUTABLE STRICT</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line">$$</span><br><span class="line"><span class="keyword">DECLARE</span></span><br><span class="line">    part_key_def   TEXT <span class="operator">=</span> pg_get_partkeydef(oid); <span class="comment">-- Output: RANGE (epoch)</span></span><br><span class="line">    begin_position <span class="type">INT</span>  <span class="operator">=</span> strpos(part_key_def, <span class="string">&#x27;(&#x27;</span>) <span class="operator">+</span> <span class="number">1</span>;</span><br><span class="line">    def_len        <span class="type">INT</span>  <span class="operator">=</span> length(part_key_def);</span><br><span class="line">    <span class="comment">-- substr(text, int, int) 第二个参数代表位置，第三个参数代表长度</span></span><br><span class="line">    part_key       TEXT <span class="operator">=</span> substr(part_key_def, begin_position, def_len <span class="operator">-</span> begin_position);</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="comment">-- 如果不是分区表，返回null</span></span><br><span class="line">    <span class="keyword">RETURN</span> <span class="built_in">cast</span>(part_key <span class="keyword">AS</span> <span class="type">VARCHAR</span>);</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line">$$ <span class="keyword">LANGUAGE</span> plpgsql;</span><br></pre></td></tr></table></figure>
<p>例子</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Range分区</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test11</span><br><span class="line">(</span><br><span class="line">    epoch   <span class="type">INTEGER</span>      <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    miner   <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    balance <span class="type">NUMERIC</span>,</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> uk_epoch_miner</span><br><span class="line">        <span class="keyword">UNIQUE</span> (epoch, miner)</span><br><span class="line">) <span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">RANGE</span> (epoch);</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> pg_get_part_table_range_key(<span class="string">&#x27;test11&#x27;</span>::regclass);</span><br><span class="line"><span class="comment">-- Output: epoch</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 哈希分区 以及分区表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test22(</span><br><span class="line">    miner <span class="type">varchar</span>(<span class="number">50</span>)</span><br><span class="line">) <span class="keyword">PARTITION</span> <span class="keyword">BY</span> HASH (miner);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test22_1 <span class="keyword">PARTITION</span> <span class="keyword">OF</span> test22 <span class="keyword">FOR</span> <span class="keyword">VALUES</span> <span class="keyword">WITH</span> (MODULUS <span class="number">2</span>, REMAINDER <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> pg_get_part_table_range_key(<span class="string">&#x27;test22&#x27;</span>::regclass);</span><br><span class="line"><span class="comment">-- Output: miner</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 列表分区</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test33(</span><br><span class="line">    miner <span class="type">varchar</span>(<span class="number">50</span>)</span><br><span class="line">) <span class="keyword">PARTITION</span> <span class="keyword">BY</span> LIST (miner);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test33_1 <span class="keyword">PARTITION</span> <span class="keyword">OF</span> test33 <span class="keyword">FOR</span> <span class="keyword">VALUES</span> <span class="keyword">IN</span> (<span class="string">&#x27;f02439&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> pg_get_part_table_range_key(<span class="string">&#x27;test33&#x27;</span>::regclass);</span><br><span class="line"><span class="comment">-- Output: miner</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 普通非分区表</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> test66(miner <span class="type">varchar</span>(<span class="number">50</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> pg_get_part_table_range_key(<span class="string">&#x27;test66&#x27;</span>::regclass);</span><br><span class="line"><span class="comment">-- Output: &lt;NULL&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="获取更新唯一键（2022-03-25-新增）"><a href="#获取更新唯一键（2022-03-25-新增）" class="headerlink" title="获取更新唯一键（2022-03-25 新增）"></a>获取更新唯一键（2022-03-25 新增）</h2><p>💡 这里约定，自动建分区表，需要建立一个且只有一个constraint定义。例如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> miner_actors</span><br><span class="line">(</span><br><span class="line">    epoch                      <span class="type">BIGINT</span>  <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    miner                      <span class="type">VARCHAR</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    owner                      <span class="type">VARCHAR</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    worker                     <span class="type">VARCHAR</span>,</span><br><span class="line">    controllers                <span class="type">VARCHAR</span>[],</span><br><span class="line">    sector_size                <span class="type">BIGINT</span>,</span><br><span class="line">    power                      <span class="type">DECIMAL</span>,</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> uk_epoch_miner_actors <span class="keyword">UNIQUE</span> (epoch, miner)</span><br><span class="line">) <span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">RANGE</span> (epoch);</span><br></pre></td></tr></table></figure>
<p>以上有一个唯一性约束<code>uk_epoch_miner_actors</code>，且只要定义一个，其它的约束以添加index方式在外部添加。</p>
<p>然后以下面的语句查询约束字段。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">     <span class="keyword">DISTINCT</span> kcu.column_name</span><br><span class="line"> <span class="keyword">FROM</span></span><br><span class="line">     information_schema.table_constraints <span class="keyword">AS</span> tc</span><br><span class="line">     <span class="keyword">JOIN</span> information_schema.key_column_usage <span class="keyword">AS</span> kcu <span class="keyword">ON</span> tc.constraint_name <span class="operator">=</span> kcu.constraint_name</span><br><span class="line">     <span class="keyword">JOIN</span> information_schema.constraint_column_usage <span class="keyword">AS</span> ccu <span class="keyword">ON</span> ccu.constraint_name <span class="operator">=</span> tc.constraint_name</span><br><span class="line"> <span class="keyword">WHERE</span> constraint_type <span class="operator">=</span> <span class="string">&#x27;UNIQUE&#x27;</span> <span class="keyword">AND</span> tc.table_name <span class="operator">=</span> <span class="string">&#x27;miner_actors&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>作用于下面的代码</p>
<h2 id="获取分区表更新列模版"><a href="#获取分区表更新列模版" class="headerlink" title="获取分区表更新列模版"></a>获取分区表更新列模版</h2><p><strong>modified at 2022-03-25</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> pg_compute_part_table_update_columns(main_table <span class="type">CHARACTER</span> <span class="type">VARYING</span>) <span class="keyword">RETURNS</span> TEXT</span><br><span class="line">    IMMUTABLE</span><br><span class="line">    <span class="keyword">LANGUAGE</span> plpgsql</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line">$$</span><br><span class="line"><span class="keyword">DECLARE</span></span><br><span class="line">    update_columns TEXT;</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">SELECT</span> string_agg(concat(column_name, <span class="string">&#x27;=$1.&#x27;</span>, column_name), <span class="string">&#x27;, &#x27;</span>) <span class="keyword">AS</span> columns</span><br><span class="line">    <span class="keyword">INTO</span> update_columns</span><br><span class="line">    <span class="keyword">FROM</span> information_schema.columns</span><br><span class="line">    <span class="keyword">WHERE</span> table_schema <span class="operator">=</span> <span class="string">&#x27;public&#x27;</span></span><br><span class="line">      <span class="keyword">AND</span> table_name <span class="operator">=</span> main_table</span><br><span class="line">      <span class="keyword">AND</span> column_name <span class="keyword">NOT</span> <span class="keyword">IN</span> (<span class="keyword">SELECT</span></span><br><span class="line">     <span class="keyword">DISTINCT</span> kcu.column_name</span><br><span class="line"> <span class="keyword">FROM</span></span><br><span class="line">     information_schema.table_constraints <span class="keyword">AS</span> tc</span><br><span class="line">     <span class="keyword">JOIN</span> information_schema.key_column_usage <span class="keyword">AS</span> kcu <span class="keyword">ON</span> tc.constraint_name <span class="operator">=</span> kcu.constraint_name</span><br><span class="line">     <span class="keyword">JOIN</span> information_schema.constraint_column_usage <span class="keyword">AS</span> ccu <span class="keyword">ON</span> ccu.constraint_name <span class="operator">=</span> tc.constraint_name</span><br><span class="line"> <span class="keyword">WHERE</span> constraint_type <span class="operator">=</span> <span class="string">&#x27;UNIQUE&#x27;</span> <span class="keyword">AND</span> tc.table_name <span class="operator">=</span> main_table);</span><br><span class="line">    <span class="keyword">RETURN</span> update_columns;</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line">$$;</span><br></pre></td></tr></table></figure>
<p>创建update 更新约束字段</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE <span class="keyword">FUNCTION</span> pg_compute_constraint_keys(main_table <span class="type">VARCHAR</span>) <span class="keyword">RETURNS</span> TEXT</span><br><span class="line">    IMMUTABLE</span><br><span class="line">    <span class="keyword">LANGUAGE</span> plpgsql</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line">$$</span><br><span class="line"><span class="keyword">DECLARE</span></span><br><span class="line">    ukeys TEXT;</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">WITH</span> t <span class="keyword">AS</span> (<span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> kcu.column_name</span><br><span class="line">               <span class="keyword">FROM</span> information_schema.table_constraints <span class="keyword">AS</span> tc</span><br><span class="line">                        <span class="keyword">JOIN</span> information_schema.key_column_usage <span class="keyword">AS</span> kcu <span class="keyword">ON</span> tc.constraint_name <span class="operator">=</span> kcu.constraint_name</span><br><span class="line">                        <span class="keyword">JOIN</span> information_schema.constraint_column_usage <span class="keyword">AS</span> ccu</span><br><span class="line">                             <span class="keyword">ON</span> ccu.constraint_name <span class="operator">=</span> tc.constraint_name</span><br><span class="line">               <span class="keyword">WHERE</span> constraint_type <span class="operator">=</span> <span class="string">&#x27;UNIQUE&#x27;</span></span><br><span class="line">                 <span class="keyword">AND</span> tc.table_name <span class="operator">=</span> main_table)</span><br><span class="line">    <span class="keyword">SELECT</span> string_agg(concat(t.column_name, <span class="string">&#x27;=$1.&#x27;</span>, t.column_name), <span class="string">&#x27; AND &#x27;</span>)</span><br><span class="line">    <span class="keyword">FROM</span> t</span><br><span class="line">    <span class="keyword">INTO</span> ukeys;</span><br><span class="line">    <span class="keyword">RETURN</span> ukeys;</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line">$$;</span><br></pre></td></tr></table></figure>
<h2 id="创建新分区"><a href="#创建新分区" class="headerlink" title="创建新分区"></a>创建新分区</h2><h3 id="分区Meta表"><a href="#分区Meta表" class="headerlink" title="分区Meta表"></a>分区Meta表</h3><p>分区meta表记录了分区表的分区信息、创建时间和分区范围。该表内的记录应在创建新分区时被记录。<code>part_type</code>字段表示范围分区、哈希分区或列表分区。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> part_tables</span><br><span class="line">(</span><br><span class="line">    id           SERIAL   <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    tb_name      <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    part_type    <span class="type">SMALLINT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>,</span><br><span class="line">    part_table   <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    begin_time   TIMESTAMPTZ,</span><br><span class="line">    end_time     TIMESTAMPTZ,</span><br><span class="line">    created_time TIMESTAMPTZ       <span class="keyword">DEFAULT</span> <span class="built_in">current_timestamp</span>,</span><br><span class="line">    <span class="comment">-- 分区表需要唯一</span></span><br><span class="line">    <span class="keyword">CONSTRAINT</span> uk_part_table_name <span class="keyword">UNIQUE</span> (tb_name, part_table),</span><br><span class="line">    <span class="keyword">CHECK</span> (part_type <span class="keyword">IN</span> (<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>)) <span class="comment">-- 0 range / 1 hash /2 list</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h3 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h3><p>这里创建新分区一定要加上 <code>IF NOT EXISTS</code>判断，在同一个事务中，批量插入时，<code>pg_catalog</code>表内未完成实际分区表的创建，所以查询出来的结果是空，会重复创建。通过<code>IF NOT EXISTS</code>规避同一事务中的重复建表。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE <span class="keyword">FUNCTION</span></span><br><span class="line">    create_new_partition_table(main_table <span class="type">VARCHAR</span>, part_table_type <span class="type">SMALLINT</span>, part_def PARTITION_TABLE_RANGE_DEFINITION)</span><br><span class="line">    <span class="keyword">RETURNS</span> <span class="type">VARCHAR</span></span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line">$$</span><br><span class="line"><span class="keyword">DECLARE</span></span><br><span class="line">    part_table_name TEXT;</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    part_table_name <span class="operator">=</span> concat_ws(<span class="string">&#x27;_&#x27;</span>, main_table, part_def.suffix);</span><br><span class="line">    <span class="keyword">EXECUTE</span> format(<span class="string">&#x27;CREATE TABLE IF NOT EXISTS %s PARTITION OF %s FOR VALUES FROM (%s) TO (%s)&#x27;</span>,</span><br><span class="line">                   part_table_name, main_table, part_def.begin_epoch, part_def.end_epoch);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> part_tables</span><br><span class="line">(</span><br><span class="line">    id           SERIAL   <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    tb_name      <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    part_type    <span class="type">SMALLINT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>,</span><br><span class="line">    part_table   <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    begin_time   TIMESTAMPTZ,</span><br><span class="line">    end_time     TIMESTAMPTZ,</span><br><span class="line">    created_time TIMESTAMPTZ       <span class="keyword">DEFAULT</span> <span class="built_in">current_timestamp</span>,</span><br><span class="line">  			<span class="comment">-- 分区表需要唯一</span></span><br><span class="line">  			<span class="keyword">CONSTRAINT</span> uk_part_table_name <span class="keyword">UNIQUE</span> (tb_name, part_table),</span><br><span class="line">        <span class="keyword">CHECK</span> (part_type <span class="keyword">IN</span> (<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>)) <span class="comment">-- 0 range / 1 hash /2 list</span></span><br><span class="line">);</span><br><span class="line">    <span class="keyword">INSERT</span> <span class="keyword">INTO</span> part_tables(tb_name, part_type, part_table, begin_time, end_time, created_time)</span><br><span class="line">    <span class="keyword">VALUES</span> (main_table, part_table_type, part_table_name,</span><br><span class="line">            part_def.begin_time, part_def.end_time, <span class="built_in">current_timestamp</span>)</span><br><span class="line">    <span class="keyword">ON</span> CONFLICT (tb_name, part_table) DO NOTHING ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">RETURN</span> part_table_name;</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line">$$ <span class="keyword">LANGUAGE</span> plpgsql;</span><br></pre></td></tr></table></figure>
<h1 id="重写规则"><a href="#重写规则" class="headerlink" title="重写规则"></a>重写规则</h1><p>通过PostgreSQL数据库规则系统，改变数据库分区表默认的INSERT/UPDATE操作，来达到在插入或更新前，判断目标分区是否存在，如不存在创建之的目的。</p>
<p>为方便后续对分区表的维护，额外建立一张独立的数据表，存放新创建的分区以及创建时间。可以根据时间对分区表合理裁剪。</p>
<h2 id="准备分区表"><a href="#准备分区表" class="headerlink" title="准备分区表"></a>准备分区表</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> example_table</span><br><span class="line">(</span><br><span class="line">    epoch <span class="type">INT</span>,</span><br><span class="line">    miner <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    balance <span class="type">DECIMAL</span>,</span><br><span class="line">    code <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> uk_epoch_miner <span class="keyword">UNIQUE</span> (epoch, miner)</span><br><span class="line">) <span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">RANGE</span> (epoch);</span><br><span class="line"></span><br><span class="line">example<span class="operator">=</span># \d<span class="operator">+</span> example_table</span><br><span class="line">              Partitioned <span class="keyword">table</span> &quot;public.example_table&quot;</span><br><span class="line"> <span class="keyword">Column</span>  <span class="operator">|</span>          Type          <span class="operator">|</span> Nullable <span class="operator">|</span> <span class="keyword">Default</span> <span class="operator">|</span> Storage  <span class="operator">|</span> Stats target <span class="operator">|</span> </span><br><span class="line"><span class="comment">---------+------------------------+----------+---------+----------+--------------+-</span></span><br><span class="line"> epoch   <span class="operator">|</span> <span class="type">integer</span>                <span class="operator">|</span>          <span class="operator">|</span>         <span class="operator">|</span> plain    <span class="operator">|</span>              <span class="operator">|</span></span><br><span class="line"> miner   <span class="operator">|</span> <span class="type">character</span> <span class="type">varying</span>(<span class="number">100</span>) <span class="operator">|</span>          <span class="operator">|</span>         <span class="operator">|</span> extended <span class="operator">|</span>              <span class="operator">|</span></span><br><span class="line"> balance <span class="operator">|</span> <span class="type">numeric</span>                <span class="operator">|</span>          <span class="operator">|</span>         <span class="operator">|</span> main     <span class="operator">|</span>              <span class="operator">|</span></span><br><span class="line"> code    <span class="operator">|</span> <span class="type">character</span> <span class="type">varying</span>(<span class="number">100</span>) <span class="operator">|</span>          <span class="operator">|</span>         <span class="operator">|</span> extended <span class="operator">|</span>              <span class="operator">|</span></span><br><span class="line"><span class="keyword">Partition</span> key: <span class="keyword">RANGE</span> (epoch)</span><br><span class="line">Indexes:</span><br><span class="line">    &quot;uk_epoch_miner&quot; <span class="keyword">UNIQUE</span> <span class="keyword">CONSTRAINT</span>, btree (epoch, miner)</span><br><span class="line">Number <span class="keyword">of</span> partitions: <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h2 id="插入（INSERT）"><a href="#插入（INSERT）" class="headerlink" title="插入（INSERT）"></a>插入（INSERT）</h2><p>替代数据库分区表默认的插入操作，需要考虑默认插入动作的几个关键要素：自动路由到对应的表分区进行插入，处理唯一键冲突。</p>
<h3 id="自动路由"><a href="#自动路由" class="headerlink" title="自动路由"></a>自动路由</h3><p>自动路由的前提是对应的表分区已存在。它分成两个步骤：</p>
<ul>
<li>创建新分区</li>
</ul>
<p>在插入行数据前，使用函数<code>pg_get_part_table_name</code>查找新插入的记录分区字段所对应的表分区，如果在数据库中不存在，则新创建。</p>
<ul>
<li>插入数据</li>
</ul>
<p>向具体的表分区插入数据。</p>
<h3 id="处理唯一键冲突"><a href="#处理唯一键冲突" class="headerlink" title="处理唯一键冲突"></a>处理唯一键冲突</h3><p>使用重写规则有一个限制，就是无法处理唯一键冲突更新。</p>
<p>无法对具有INSERT或者UPDATE规则的表使用带有ON CONFLICT子句的INSERT</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> from_table <span class="keyword">VALUES</span> (<span class="number">3</span>, <span class="string">&#x27;333&#x27;</span>) <span class="keyword">ON</span> CONFLICT(col1) DO <span class="keyword">UPDATE</span> <span class="keyword">SET</span> data <span class="operator">=</span> excluded.data;</span><br></pre></td></tr></table></figure>
<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>A000  feature_not_supported</span><br></pre></td></tr></table></figure>
<p>因此，需要处理<code>unique_violation</code>的执行错误。使用<code>EXCEPTION</code>捕获<code>unique_violation</code>的错误，执行分区表UPDATE。</p>
<p>注意，一旦捕获<code>unique_violation</code>并处理实现唯一键冲突更新的操作，意味着替代的INSERT操作将天生具有upsert的功能。</p>
<h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><p>一、创建插入函数。</p>
<p>根据数据库规则语法，规则仅支持SELECT/INSERT/UPDATE/DELETE操作，因此要执行一系列动作需要创建一个存储过程来实现。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE <span class="keyword">FUNCTION</span> insert_action(table_row miner_actors) <span class="keyword">RETURNS</span> VOID</span><br><span class="line"><span class="keyword">AS</span> $$</span><br><span class="line"><span class="keyword">DECLARE</span></span><br><span class="line">    main_table <span class="type">VARCHAR</span> <span class="operator">=</span> <span class="string">&#x27;example_table&#x27;</span>;</span><br><span class="line">    part_table_type <span class="type">SMALLINT</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    range_ts        TIMESTAMPTZ                      <span class="operator">=</span> calc_timestamp_by_epoch(table_row.epoch);</span><br><span class="line">    part_def        PARTITION_TABLE_RANGE_DEFINITION <span class="operator">=</span> calc_partition_range_by_day(range_ts);</span><br><span class="line">    part_table_name <span class="type">VARCHAR</span>                          <span class="operator">=</span> pg_get_part_table_name(main_table, part_def.suffix);</span><br><span class="line">    update_columns  TEXT;</span><br><span class="line">    constraint_keys TEXT;</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    RAISE NOTICE <span class="string">&#x27;suffix:%; begin_epoch:%; end_epoch:%; begin_time:%; end_time:%&#x27;</span>,</span><br><span class="line">        part_def.suffix, part_def.begin_epoch, part_def.end_epoch, part_def.begin_time, part_def.end_time;</span><br><span class="line">    RAISE NOTICE <span class="string">&#x27;part_table_name: %&#x27;</span>, part_table_name;</span><br><span class="line">    IF part_table_name ISNULL <span class="keyword">THEN</span></span><br><span class="line">        <span class="keyword">SELECT</span> create_new_partition_table(main_table, part_table_type, part_def)</span><br><span class="line">        <span class="keyword">INTO</span> part_table_name;</span><br><span class="line">    <span class="keyword">END</span> IF;</span><br><span class="line">    <span class="keyword">EXECUTE</span> format(<span class="string">&#x27;INSERT INTO %s SELECT $1.*&#x27;</span>, part_table_name) <span class="keyword">USING</span> table_row;</span><br><span class="line">EXCEPTION</span><br><span class="line">    <span class="keyword">WHEN</span> unique_violation <span class="keyword">THEN</span></span><br><span class="line">        update_columns <span class="operator">=</span> pg_compute_part_table_update_columns(main_table);</span><br><span class="line">        constraint_keys <span class="operator">=</span> pg_compute_constraint_keys(main_table);</span><br><span class="line">        RAISE NOTICE <span class="string">&#x27;%&#x27;</span>, format(<span class="string">&#x27;UPDATE %s SET %s WHERE %s&#x27;</span>, part_table_name, update_columns, constraint_keys);</span><br><span class="line">        <span class="keyword">EXECUTE</span> format(<span class="string">&#x27;UPDATE %s SET %s WHERE %s&#x27;</span>, part_table_name, update_columns, constraint_keys) <span class="keyword">USING</span> table_row;</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line">$$ <span class="keyword">LANGUAGE</span> plpgsql;</span><br></pre></td></tr></table></figure>
<p>二、创建INSERT RULE。</p>
<p>在分区表主表上创建一条规则，其方式是<code>INSTEAD</code>默认INSERT操作。其中<code>new</code>是一个内置变量，代表新插入的记录行。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> RULE upsert_part_data <span class="keyword">AS</span> <span class="keyword">ON</span> <span class="keyword">INSERT</span> <span class="keyword">TO</span> example_table DO INSTEAD <span class="keyword">SELECT</span> insert_action(<span class="keyword">new</span>);</span><br></pre></td></tr></table></figure>
<p> 三、插入</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> example_table(epoch, miner, balance, code) <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">&#x27;f02438&#x27;</span>, <span class="string">&#x27;100&#x27;</span>, <span class="string">&#x27;Good&#x27;</span>);</span><br><span class="line"></span><br><span class="line">example<span class="operator">=</span># \d<span class="operator">+</span> example_table</span><br><span class="line">                 Partitioned <span class="keyword">table</span> &quot;public.example_table&quot;</span><br><span class="line"> <span class="keyword">Column</span>  <span class="operator">|</span>          Type          <span class="operator">|</span> Nullable <span class="operator">|</span> <span class="keyword">Default</span> <span class="operator">|</span> Storage  <span class="operator">|</span> Stats target <span class="operator">|</span> </span><br><span class="line"><span class="comment">---------+------------------------+----------+---------+----------+--------------+-</span></span><br><span class="line"> epoch   <span class="operator">|</span> <span class="type">integer</span>                <span class="operator">|</span>          <span class="operator">|</span>         <span class="operator">|</span> plain    <span class="operator">|</span>              <span class="operator">|</span></span><br><span class="line"> miner   <span class="operator">|</span> <span class="type">character</span> <span class="type">varying</span>(<span class="number">100</span>) <span class="operator">|</span>          <span class="operator">|</span>         <span class="operator">|</span> extended <span class="operator">|</span>              <span class="operator">|</span></span><br><span class="line"> balance <span class="operator">|</span> <span class="type">numeric</span>                <span class="operator">|</span>          <span class="operator">|</span>         <span class="operator">|</span> main     <span class="operator">|</span>              <span class="operator">|</span></span><br><span class="line"> code    <span class="operator">|</span> <span class="type">character</span> <span class="type">varying</span>(<span class="number">100</span>) <span class="operator">|</span>          <span class="operator">|</span>         <span class="operator">|</span> extended <span class="operator">|</span>              <span class="operator">|</span></span><br><span class="line"><span class="keyword">Partition</span> key: <span class="keyword">RANGE</span> (epoch)</span><br><span class="line">Indexes:</span><br><span class="line">    &quot;uk_epoch_miner&quot; <span class="keyword">UNIQUE</span> <span class="keyword">CONSTRAINT</span>, btree (epoch, miner)</span><br><span class="line">Rules:</span><br><span class="line">    upsert_part_data <span class="keyword">AS</span></span><br><span class="line">    <span class="keyword">ON</span> <span class="keyword">INSERT</span> <span class="keyword">TO</span> example_table DO INSTEAD  <span class="keyword">SELECT</span> insert_action(new.<span class="operator">*</span>) <span class="keyword">AS</span> insert_action</span><br><span class="line">Partitions: example_table_2020_08_25_0_2159 <span class="keyword">FOR</span> <span class="keyword">VALUES</span> <span class="keyword">FROM</span> (<span class="number">0</span>) <span class="keyword">TO</span> (<span class="number">2159</span>)</span><br></pre></td></tr></table></figure>
<h2 id="更新（UPDATE）"><a href="#更新（UPDATE）" class="headerlink" title="更新（UPDATE）"></a>更新（UPDATE）</h2><p>替代数据库分区表默认更新操作，需要考虑以下几个因素：普通更新和分区移动。</p>
<h3 id="普通更新"><a href="#普通更新" class="headerlink" title="普通更新"></a>普通更新</h3><p>对于分区列相同的更新，不需要执行删除命令，也不需要创建新不存在的分区表，直接UPDATE目标表。</p>
<h3 id="分区移动"><a href="#分区移动" class="headerlink" title="分区移动"></a>分区移动</h3><p>对于更新了分区列的数据，要查找新的分区表是否存在，如果不存在需要创建。然后将旧数据删除，在新表中插入新纪录。</p>
<h3 id="具体实现-1"><a href="#具体实现-1" class="headerlink" title="具体实现"></a>具体实现</h3><p>一、创建存储过程</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE <span class="keyword">FUNCTION</span></span><br><span class="line">    update_action(new_row miner_actors, old_row miner_actors)</span><br><span class="line">    <span class="keyword">RETURNS</span> VOID <span class="keyword">AS</span></span><br><span class="line">$$</span><br><span class="line"><span class="keyword">DECLARE</span></span><br><span class="line">    main_table          <span class="type">VARCHAR</span>                          <span class="operator">=</span> <span class="string">&#x27;example_table&#x27;</span>;</span><br><span class="line">    part_table_type <span class="type">SMALLINT</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    new_range_ts        TIMESTAMPTZ                      <span class="operator">=</span> calc_timestamp_by_epoch(new_row.epoch);</span><br><span class="line">    new_part_def        PARTITION_TABLE_RANGE_DEFINITION <span class="operator">=</span> calc_partition_range_by_day(new_range_ts);</span><br><span class="line">    new_part_table_name <span class="type">VARCHAR</span>                          <span class="operator">=</span> pg_get_part_table_name(main_table, new_part_def.suffix);</span><br><span class="line">    old_range_ts        TIMESTAMPTZ;</span><br><span class="line">    old_part_def        PARTITION_TABLE_RANGE_DEFINITION;</span><br><span class="line">    old_part_table_name <span class="type">VARCHAR</span>;</span><br><span class="line">    update_columns      TEXT;</span><br><span class="line">    constraint_keys TEXT;</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    constraint_keys <span class="operator">=</span> pg_compute_constraint_keys(main_table);</span><br><span class="line">    IF new_row.epoch <span class="operator">=</span> old_row.epoch <span class="keyword">THEN</span></span><br><span class="line">        RAISE NOTICE <span class="string">&#x27;update in same table&#x27;</span>;</span><br><span class="line"><span class="comment">--         旧数据存在或条件不存在，这里只是做单纯的update更新分区数据</span></span><br><span class="line">        update_columns <span class="operator">=</span> pg_compute_part_table_update_columns(main_table);</span><br><span class="line">        <span class="keyword">EXECUTE</span> format(<span class="string">&#x27;UPDATE %s SET %s WHERE %s&#x27;</span>, new_part_table_name, update_columns, constraint_keys) <span class="keyword">USING</span> new_row;</span><br><span class="line">        <span class="keyword">RETURN</span>;</span><br><span class="line">    <span class="keyword">END</span> IF;</span><br><span class="line"></span><br><span class="line">    IF new_part_table_name ISNULL <span class="keyword">THEN</span></span><br><span class="line">        <span class="keyword">SELECT</span> create_new_partition_table(main_table, part_table_type, new_part_def)</span><br><span class="line">        <span class="keyword">INTO</span> new_part_table_name;</span><br><span class="line">    <span class="keyword">END</span> IF;</span><br><span class="line"></span><br><span class="line">    old_range_ts <span class="operator">=</span> calc_timestamp_by_epoch(old_row.epoch);</span><br><span class="line">    old_part_def <span class="operator">=</span> calc_partition_range_by_day(old_range_ts);</span><br><span class="line">    old_part_table_name <span class="operator">=</span> pg_get_part_table_name(main_table, old_part_def.suffix);</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- delete 动作要放在这里，这里有移动操作。</span></span><br><span class="line">    <span class="keyword">EXECUTE</span> format(<span class="string">&#x27;DELETE FROM %s WHERE %s&#x27;</span>, old_part_table_name, constraint_keys) <span class="keyword">USING</span> old_row;</span><br><span class="line">    <span class="keyword">EXECUTE</span> format(<span class="string">&#x27;INSERT INTO %s SELECT $1.*&#x27;</span>, new_part_table_name) <span class="keyword">USING</span> new_row;</span><br><span class="line">    <span class="keyword">RETURN</span>;</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line">$$ <span class="keyword">LANGUAGE</span> plpgsql;</span><br></pre></td></tr></table></figure>
<p>二、创建UPDATE RULE</p>
<p>在分区表主表上创建一条更新规则，其方式是<code>INSTEAD</code>默认UPDATE操作。其中<code>new</code>和<code>old</code>是内置变量，代表新更新的数据和旧数据行。</p>
<p><strong>这里的旧的数据行是通过where条件获知的，新的数据行是根据update内set获知的。所以在执行该更新执行计划的时候它会先收集数据，然后执行规则。所以old可以根据唯一键来查找。</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> RULE update_part_data <span class="keyword">AS</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">TO</span> example_table DO INSTEAD <span class="keyword">SELECT</span> update_action(<span class="keyword">new</span>, <span class="keyword">old</span>);</span><br></pre></td></tr></table></figure>
<p>  三、更新</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> example_table <span class="keyword">SET</span> epoch <span class="operator">=</span> <span class="number">3000</span>, balance <span class="operator">=</span> <span class="string">&#x27;99&#x27;</span>, code <span class="operator">=</span> <span class="string">&#x27;Good+&#x27;</span> <span class="keyword">WHERE</span> epoch <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">example<span class="operator">=</span># \d<span class="operator">+</span> example_table</span><br><span class="line">                                 Partitioned <span class="keyword">table</span> &quot;public.example_table&quot;</span><br><span class="line"> <span class="keyword">Column</span>  <span class="operator">|</span>          Type          <span class="operator">|</span> Nullable <span class="operator">|</span> <span class="keyword">Default</span> <span class="operator">|</span> Storage  <span class="operator">|</span> Stats target <span class="operator">|</span> </span><br><span class="line"><span class="comment">---------+------------------------+----------+---------+----------+--------------+-</span></span><br><span class="line"> epoch   <span class="operator">|</span> <span class="type">integer</span>                <span class="operator">|</span>          <span class="operator">|</span>         <span class="operator">|</span> plain    <span class="operator">|</span>              <span class="operator">|</span></span><br><span class="line"> miner   <span class="operator">|</span> <span class="type">character</span> <span class="type">varying</span>(<span class="number">100</span>) <span class="operator">|</span>          <span class="operator">|</span>         <span class="operator">|</span> extended <span class="operator">|</span>              <span class="operator">|</span></span><br><span class="line"> balance <span class="operator">|</span> <span class="type">numeric</span>                <span class="operator">|</span>          <span class="operator">|</span>         <span class="operator">|</span> main     <span class="operator">|</span>              <span class="operator">|</span></span><br><span class="line"> code    <span class="operator">|</span> <span class="type">character</span> <span class="type">varying</span>(<span class="number">100</span>) <span class="operator">|</span>          <span class="operator">|</span>         <span class="operator">|</span> extended <span class="operator">|</span>              <span class="operator">|</span></span><br><span class="line"><span class="keyword">Partition</span> key: <span class="keyword">RANGE</span> (epoch)</span><br><span class="line">Indexes:</span><br><span class="line">    &quot;uk_epoch_miner&quot; <span class="keyword">UNIQUE</span> <span class="keyword">CONSTRAINT</span>, btree (epoch, miner)</span><br><span class="line">Rules:</span><br><span class="line">    update_part_data <span class="keyword">AS</span></span><br><span class="line">    <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">TO</span> example_table DO INSTEAD  <span class="keyword">SELECT</span> update_action(new.<span class="operator">*</span>, old.<span class="operator">*</span>) <span class="keyword">AS</span> update_action</span><br><span class="line">    upsert_part_data <span class="keyword">AS</span></span><br><span class="line">    <span class="keyword">ON</span> <span class="keyword">INSERT</span> <span class="keyword">TO</span> example_table DO INSTEAD  <span class="keyword">SELECT</span> insert_action(new.<span class="operator">*</span>) <span class="keyword">AS</span> insert_action</span><br><span class="line">Partitions: example_table_2020_08_25_0_2159 <span class="keyword">FOR</span> <span class="keyword">VALUES</span> <span class="keyword">FROM</span> (<span class="number">0</span>) <span class="keyword">TO</span> (<span class="number">2159</span>),</span><br><span class="line">            example_table_2020_08_26_2160_5039 <span class="keyword">FOR</span> <span class="keyword">VALUES</span> <span class="keyword">FROM</span> (<span class="number">2160</span>) <span class="keyword">TO</span> (<span class="number">5039</span>)</span><br></pre></td></tr></table></figure>
<h1 id="分区表维护"><a href="#分区表维护" class="headerlink" title="分区表维护"></a>分区表维护</h1><h2 id="规则替换"><a href="#规则替换" class="headerlink" title="规则替换"></a>规则替换</h2><p>封装一个存储过程，将创建insert_action函数和update_action函数放入其中。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE <span class="keyword">PROCEDURE</span></span><br><span class="line">    create_auto_partition(table_name <span class="type">VARCHAR</span>, range_type <span class="type">VARCHAR</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;week&#x27;</span>)</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line">$$</span><br><span class="line"><span class="keyword">DECLARE</span></span><br><span class="line">    insert_func_name TEXT :<span class="operator">=</span> concat_ws(<span class="string">&#x27;_&#x27;</span>, table_name, <span class="string">&#x27;insert_action&#x27;</span>);</span><br><span class="line">    update_func_name TEXT :<span class="operator">=</span> concat_ws(<span class="string">&#x27;_&#x27;</span>, table_name, <span class="string">&#x27;update_action&#x27;</span>);</span><br><span class="line">    insert_tpl       TEXT;</span><br><span class="line">    update_tpl       TEXT;</span><br><span class="line">    range_func_name  TEXT;</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    IF range_type <span class="operator">=</span> <span class="string">&#x27;day&#x27;</span> <span class="keyword">THEN</span></span><br><span class="line">        range_func_name <span class="operator">=</span> <span class="string">&#x27;calc_partition_range_by_day&#x27;</span>;</span><br><span class="line">    ELSEIF range_type <span class="operator">=</span> <span class="string">&#x27;week&#x27;</span> <span class="keyword">THEN</span></span><br><span class="line">        range_func_name <span class="operator">=</span> <span class="string">&#x27;calc_partition_range_by_week_of_year&#x27;</span>;</span><br><span class="line">    ELSEIF range_type <span class="operator">=</span> <span class="string">&#x27;month&#x27;</span> <span class="keyword">THEN</span></span><br><span class="line">        range_func_name <span class="operator">=</span> <span class="string">&#x27;calc_partition_range_by_month&#x27;</span>;</span><br><span class="line">    ELSEIF range_type <span class="operator">=</span> <span class="string">&#x27;year&#x27;</span> <span class="keyword">THEN</span></span><br><span class="line">        range_func_name <span class="operator">=</span> <span class="string">&#x27;calc_partition_range_by_year&#x27;</span>;</span><br><span class="line">    <span class="keyword">ELSE</span></span><br><span class="line">        RAISE EXCEPTION <span class="string">&#x27;unsupported range type(only in day, week, month, year)&#x27;</span>;</span><br><span class="line">    <span class="keyword">END</span> IF;</span><br><span class="line">    insert_tpl :<span class="operator">=</span> E<span class="string">&#x27;CREATE OR REPLACE FUNCTION &#x27;</span> <span class="operator">||</span> insert_func_name <span class="operator">||</span> <span class="string">&#x27;(table_row &#x27;</span> <span class="operator">||</span> table_name <span class="operator">||</span> <span class="string">&#x27;) &#x27;</span> <span class="operator">||</span></span><br><span class="line">                  <span class="string">&#x27;RETURNS VOID AS &#x27;</span> <span class="operator">||</span></span><br><span class="line">                  <span class="string">&#x27;$body$ &#x27;</span> <span class="operator">||</span></span><br><span class="line">                  <span class="string">&#x27;DECLARE &#x27;</span> <span class="operator">||</span></span><br><span class="line">                  <span class="string">&#x27;    main_table VARCHAR = &#x27;&#x27;&#x27;</span> <span class="operator">||</span> table_name <span class="operator">||</span> <span class="string">&#x27;&#x27;&#x27;; &#x27;</span> <span class="operator">||</span></span><br><span class="line">                  <span class="string">&#x27;part_table_type SMALLINT = 0; &#x27;</span> <span class="operator">||</span></span><br><span class="line">                  <span class="string">&#x27;range_ts        TIMESTAMPTZ                      = calc_timestamp_by_epoch(table_row.epoch); &#x27;</span> <span class="operator">||</span></span><br><span class="line">                  <span class="string">&#x27;part_def        PARTITION_TABLE_RANGE_DEFINITION = &#x27;</span> <span class="operator">||</span> range_func_name <span class="operator">||</span> <span class="string">&#x27;(range_ts); &#x27;</span> <span class="operator">||</span></span><br><span class="line">                  <span class="string">&#x27;part_table_name VARCHAR                          = pg_get_part_table_name(main_table, part_def.suffix); &#x27;</span> <span class="operator">||</span></span><br><span class="line">                  <span class="string">&#x27;update_columns  TEXT; &#x27;</span> <span class="operator">||</span></span><br><span class="line">                  <span class="string">&#x27;constraint_keys TEXT; &#x27;</span> <span class="operator">||</span></span><br><span class="line">                  <span class="string">&#x27;BEGIN &#x27;</span> <span class="operator">||</span></span><br><span class="line">                  <span class="string">&#x27;IF part_table_name ISNULL THEN &#x27;</span> <span class="operator">||</span></span><br><span class="line">                  <span class="string">&#x27;SELECT create_new_partition_table(main_table, part_table_type, part_def) &#x27;</span> <span class="operator">||</span></span><br><span class="line">                  <span class="string">&#x27;INTO part_table_name; &#x27;</span> <span class="operator">||</span></span><br><span class="line">                  <span class="string">&#x27;END IF; &#x27;</span> <span class="operator">||</span></span><br><span class="line">                  <span class="string">&#x27;EXECUTE format(&#x27;&#x27;INSERT INTO %s SELECT $1.*&#x27;&#x27;, part_table_name) USING table_row; &#x27;</span> <span class="operator">||</span></span><br><span class="line">                  <span class="string">&#x27;EXCEPTION &#x27;</span> <span class="operator">||</span></span><br><span class="line">                  <span class="string">&#x27;    WHEN unique_violation THEN &#x27;</span> <span class="operator">||</span></span><br><span class="line">                  <span class="string">&#x27;        update_columns = pg_compute_part_table_update_columns(main_table); &#x27;</span> <span class="operator">||</span></span><br><span class="line">                  <span class="string">&#x27;        constraint_keys = pg_compute_constraint_keys(main_table); &#x27;</span> <span class="operator">||</span></span><br><span class="line">                  <span class="string">&#x27;EXECUTE format(&#x27;&#x27;UPDATE %s SET %s WHERE %s &#x27;&#x27;, part_table_name, update_columns, constraint_keys) USING table_row; &#x27;</span> <span class="operator">||</span></span><br><span class="line">                  <span class="string">&#x27;END $body$ LANGUAGE plpgsql&#x27;</span>;</span><br><span class="line">    <span class="keyword">EXECUTE</span> insert_tpl;</span><br><span class="line">    <span class="keyword">EXECUTE</span> format(<span class="string">&#x27;DROP RULE IF EXISTS upsert_part_data ON %s&#x27;</span>, table_name);</span><br><span class="line">    <span class="keyword">EXECUTE</span> format(<span class="string">&#x27;CREATE RULE upsert_part_data AS ON INSERT TO %s DO INSTEAD SELECT %s(new)&#x27;</span>, table_name, insert_func_name);</span><br><span class="line"></span><br><span class="line">    update_tpl :<span class="operator">=</span> <span class="string">&#x27;CREATE OR REPLACE FUNCTION &#x27;</span><span class="operator">||</span> update_func_name <span class="operator">||</span> <span class="string">&#x27;(new_row &#x27;</span><span class="operator">||</span> table_name <span class="operator">||</span><span class="string">&#x27;, old_row &#x27;</span><span class="operator">||</span> table_name <span class="operator">||</span><span class="string">&#x27;)&#x27;</span> <span class="operator">||</span></span><br><span class="line"><span class="string">&#x27;    RETURNS VOID AS &#x27;</span> <span class="operator">||</span></span><br><span class="line"><span class="string">&#x27;$body$ &#x27;</span> <span class="operator">||</span></span><br><span class="line"><span class="string">&#x27;DECLARE &#x27;</span> <span class="operator">||</span></span><br><span class="line"><span class="string">&#x27;    main_table VARCHAR = &#x27;&#x27;&#x27;</span><span class="operator">||</span> table_name <span class="operator">||</span><span class="string">&#x27;&#x27;&#x27;; &#x27;</span> <span class="operator">||</span></span><br><span class="line"><span class="string">&#x27;part_table_type SMALLINT = 0; &#x27;</span> <span class="operator">||</span></span><br><span class="line"><span class="string">&#x27;new_range_ts        TIMESTAMPTZ                      = calc_timestamp_by_epoch(new_row.epoch); &#x27;</span> <span class="operator">||</span></span><br><span class="line"><span class="string">&#x27;new_part_def        PARTITION_TABLE_RANGE_DEFINITION = &#x27;</span><span class="operator">||</span> range_func_name <span class="operator">||</span><span class="string">&#x27;(new_range_ts); &#x27;</span> <span class="operator">||</span></span><br><span class="line"><span class="string">&#x27;new_part_table_name VARCHAR                          = pg_get_part_table_name(main_table, new_part_def.suffix); &#x27;</span> <span class="operator">||</span></span><br><span class="line"><span class="string">&#x27;old_range_ts        TIMESTAMPTZ; &#x27;</span> <span class="operator">||</span></span><br><span class="line"><span class="string">&#x27;old_part_def        PARTITION_TABLE_RANGE_DEFINITION; &#x27;</span> <span class="operator">||</span></span><br><span class="line"><span class="string">&#x27;old_part_table_name VARCHAR; &#x27;</span> <span class="operator">||</span></span><br><span class="line"><span class="string">&#x27;update_columns      TEXT; &#x27;</span> <span class="operator">||</span></span><br><span class="line"><span class="string">&#x27;constraint_keys     TEXT;&#x27;</span>  <span class="operator">||</span></span><br><span class="line"><span class="string">&#x27;BEGIN &#x27;</span> <span class="operator">||</span></span><br><span class="line"><span class="string">&#x27;constraint_keys = pg_compute_constraint_keys(main_table); &#x27;</span> <span class="operator">||</span></span><br><span class="line"><span class="string">&#x27;IF new_row.epoch = old_row.epoch THEN &#x27;</span> <span class="operator">||</span></span><br><span class="line"><span class="string">&#x27;update_columns = pg_compute_part_table_update_columns(main_table); &#x27;</span> <span class="operator">||</span></span><br><span class="line"><span class="string">&#x27;EXECUTE format(&#x27;&#x27;UPDATE %s SET %s WHERE %s&#x27;&#x27;, new_part_table_name, update_columns, constraint_keys) USING new_row; &#x27;</span> <span class="operator">||</span></span><br><span class="line"><span class="string">&#x27;RETURN; &#x27;</span> <span class="operator">||</span></span><br><span class="line"><span class="string">&#x27;END IF; &#x27;</span> <span class="operator">||</span></span><br><span class="line"><span class="string">&#x27;IF new_part_table_name ISNULL THEN &#x27;</span> <span class="operator">||</span></span><br><span class="line"><span class="string">&#x27;SELECT create_new_partition_table(main_table, part_table_type, new_part_def) &#x27;</span> <span class="operator">||</span></span><br><span class="line"><span class="string">&#x27;INTO new_part_table_name; &#x27;</span> <span class="operator">||</span></span><br><span class="line"><span class="string">&#x27;END IF; &#x27;</span> <span class="operator">||</span></span><br><span class="line"><span class="string">&#x27;old_range_ts = calc_timestamp_by_epoch(old_row.epoch); &#x27;</span> <span class="operator">||</span></span><br><span class="line"><span class="string">&#x27;old_part_def = &#x27;</span> <span class="operator">||</span> range_func_name <span class="operator">||</span> <span class="string">&#x27;(old_range_ts); &#x27;</span> <span class="operator">||</span></span><br><span class="line"><span class="string">&#x27;old_part_table_name = pg_get_part_table_name(main_table, old_part_def.suffix); &#x27;</span> <span class="operator">||</span></span><br><span class="line"><span class="string">&#x27;EXECUTE format(&#x27;&#x27;DELETE FROM %s WHERE %s&#x27;&#x27;, old_part_table_name, constraint_keys) USING old_row; &#x27;</span> <span class="operator">||</span></span><br><span class="line"><span class="string">&#x27;EXECUTE format(&#x27;&#x27;INSERT INTO %s SELECT $1.*&#x27;&#x27;, new_part_table_name) USING new_row; &#x27;</span> <span class="operator">||</span></span><br><span class="line"><span class="string">&#x27;RETURN; &#x27;</span> <span class="operator">||</span></span><br><span class="line"><span class="string">&#x27;END $body$ LANGUAGE plpgsql&#x27;</span>;</span><br><span class="line">    <span class="keyword">EXECUTE</span> update_tpl;</span><br><span class="line">    <span class="keyword">EXECUTE</span> format(<span class="string">&#x27;DROP RULE IF EXISTS update_part_data ON %s&#x27;</span>, table_name);</span><br><span class="line">    <span class="keyword">EXECUTE</span> format(<span class="string">&#x27;CREATE RULE update_part_data AS ON UPDATE TO %s DO INSTEAD SELECT %s(new, old)&#x27;</span>, table_name, update_func_name);</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line">$$ <span class="keyword">LANGUAGE</span> plpgsql;</span><br></pre></td></tr></table></figure>
<p>调用</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CALL</span> create_auto_partition(<span class="string">&#x27;example_table&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>上述简化了操作步骤。对于公共函数仍然需要提前部署。</p>
<h2 id="裁剪"><a href="#裁剪" class="headerlink" title="裁剪"></a>裁剪</h2><p>//TODO</p>
<h2 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h2><p>//TODO</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="创建自动分区表的步骤"><a href="#创建自动分区表的步骤" class="headerlink" title="创建自动分区表的步骤"></a>创建自动分区表的步骤</h2><p>一、准备公共函数</p>
<p>见 <strong>函数</strong> 一章，和 <strong>规则替换</strong> 一节</p>
<p>二、创建分区表</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> example_table</span><br><span class="line">(</span><br><span class="line">    epoch <span class="type">INT</span>,</span><br><span class="line">    miner <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    balance <span class="type">DECIMAL</span>,</span><br><span class="line">    code <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> uk_epoch_miner <span class="keyword">UNIQUE</span> (epoch, miner)</span><br><span class="line">) <span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">RANGE</span> (epoch);</span><br></pre></td></tr></table></figure>
<p>三、创建INSERT/UPDATE替换函数</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CALL</span> create_auto_partition(<span class="string">&#x27;example_table&#x27;</span>);</span><br></pre></td></tr></table></figure>
<h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> example_table(epoch, miner, balance, code) <span class="keyword">SELECT</span> i, <span class="string">&#x27;f03367&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;Good&#x27;</span> <span class="keyword">FROM</span> generate_series(<span class="number">1</span>, <span class="number">1500000</span>) g(i);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- completed in 10 m 26 s 339 ms</span></span><br></pre></td></tr></table></figure>
<p>插入150万测试数据，花费10分钟左右。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><h2 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h2><p><a target="_blank" rel="noopener" href="http://postgres.cn/docs/13/ddl-partitioning.html">表分区</a></p>
<p><a target="_blank" rel="noopener" href="http://postgres.cn/docs/13/errcodes-appendix.html">附录 A. PostgreSQL错误代码</a></p>
<p><a target="_blank" rel="noopener" href="http://www.postgres.cn/docs/13/sql-createrule.html">CREATE RULE</a></p>
<h2 id="网上文章"><a href="#网上文章" class="headerlink" title="网上文章"></a>网上文章</h2><p><a target="_blank" rel="noopener" href="https://itbilu.com/database/postgre/E12ilqZXx.html">PostgreSQL中的函数之日期时间函数</a></p>
<p><a target="_blank" rel="noopener" href="https://developer.aliyun.com/article/603280">自动创建分区实践(写入触发器)</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/zhangyongze_z/article/details/114820640">PostgreSQL 异常捕获（EXCEPTION）</a></p>

    </div>

    
    
    

      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/PostgreSQL/" rel="tag"><i class="fa fa-tag"></i> PostgreSQL</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/proxy-re-encrypt/" rel="prev" title="谈谈我对代理重加密的理解">
      <i class="fa fa-chevron-left"></i> 谈谈我对代理重加密的理解
    </a></div>
      <div class="post-nav-item">
    <a href="/datacap-quality-adj-power/" rel="next" title="如何使用DataCap获得10倍有效算力">
      如何使用DataCap获得10倍有效算力 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    
  <div class="comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
    </div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%A1%A8%E5%88%86%E5%8C%BA%E6%96%B9%E6%A1%88"><span class="nav-number">1.</span> <span class="nav-text">表分区方案</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%EF%BC%9A%E8%AF%A5%E9%A1%B9%E7%9B%AE%E4%B8%8D%E5%86%8D%E5%A4%84%E4%BA%8E%E5%BC%80%E5%8F%91%E9%98%B6%E6%AE%B5"><span class="nav-number">1.0.1.</span> <span class="nav-text">注意：该项目不再处于开发阶段</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%88%86%E5%8C%BA%EF%BC%88DDL-Partition%EF%BC%89"><span class="nav-number">2.</span> <span class="nav-text">声明式分区（DDL-Partition）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%89%B9%E7%82%B9"><span class="nav-number">2.1.</span> <span class="nav-text">特点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%BB%98%E8%AE%A4%E5%88%86%E5%8C%BA"><span class="nav-number">2.1.1.</span> <span class="nav-text">默认分区</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E5%8C%BA%E8%87%AA%E5%8A%A8%E7%B4%A2%E5%BC%95"><span class="nav-number">2.1.2.</span> <span class="nav-text">分区自动索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B7%A8%E5%88%86%E5%8C%BA%E7%A7%BB%E5%8A%A8%E6%95%B0%E6%8D%AE"><span class="nav-number">2.1.3.</span> <span class="nav-text">跨分区移动数据</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%99%90%E5%88%B6"><span class="nav-number">2.2.</span> <span class="nav-text">限制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="nav-number">2.3.</span> <span class="nav-text">执行流程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A6%E5%8F%91%E5%99%A8%E8%A1%8C%E4%B8%BA"><span class="nav-number">2.3.1.</span> <span class="nav-text">触发器行为</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%88%86%E5%8C%BA%E8%A1%A8"><span class="nav-number">2.3.1.1.</span> <span class="nav-text">创建分区表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E8%A7%A6%E5%8F%91%E5%99%A8%E5%87%BD%E6%95%B0"><span class="nav-number">2.3.1.2.</span> <span class="nav-text">创建触发器函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E8%A7%A6%E5%8F%91%E5%99%A8"><span class="nav-number">2.3.1.3.</span> <span class="nav-text">创建触发器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%E4%B8%80%E6%9D%A1%E6%95%B0%E6%8D%AE"><span class="nav-number">2.3.1.4.</span> <span class="nav-text">插入一条数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%E4%B8%8D%E5%AD%98%E5%9C%A8%E5%88%86%E5%8C%BA%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="nav-number">2.3.1.5.</span> <span class="nav-text">插入不存在分区的数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9%E8%A7%A6%E5%8F%91%E5%99%A8%E5%87%BD%E6%95%B0"><span class="nav-number">2.3.1.6.</span> <span class="nav-text">修改触发器函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%8D%E6%AC%A1%E4%BF%AE%E6%94%B9%E8%A7%A6%E5%8F%91%E5%99%A8%E5%87%BD%E6%95%B0"><span class="nav-number">2.3.1.7.</span> <span class="nav-text">再次修改触发器函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E8%B7%AF%E7%94%B1%E6%B5%81%E7%A8%8B"><span class="nav-number">2.3.2.</span> <span class="nav-text">自动路由流程</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%A7%84%E5%88%99%E7%B3%BB%E7%BB%9F"><span class="nav-number">3.</span> <span class="nav-text">规则系统</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%A8%E6%B3%95"><span class="nav-number">3.1.</span> <span class="nav-text">用法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E6%B5%81%E7%A8%8B"><span class="nav-number">3.2.</span> <span class="nav-text">设计流程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%87%BD%E6%95%B0-%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B"><span class="nav-number">4.</span> <span class="nav-text">函数(存储过程)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A1%A8%E5%88%86%E5%8C%BA%E5%90%8D%E7%A7%B0%E7%BA%A6%E5%AE%9A"><span class="nav-number">4.1.</span> <span class="nav-text">表分区名称约定</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A1%A8%E5%90%8D%E7%A7%B0%E7%BA%A6%E5%AE%9A"><span class="nav-number">4.1.1.</span> <span class="nav-text">表名称约定</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E5%8C%BA%E8%8C%83%E5%9B%B4%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89"><span class="nav-number">4.1.2.</span> <span class="nav-text">分区范围类型定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E5%8C%BA%E8%8C%83%E5%9B%B4%E5%AE%9E%E7%8E%B0"><span class="nav-number">4.1.3.</span> <span class="nav-text">分区范围实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%89%E5%A4%A9%E5%88%86%E5%8C%BA"><span class="nav-number">4.1.3.1.</span> <span class="nav-text">按天分区</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%89%E5%91%A8%E5%88%86%E5%8C%BA"><span class="nav-number">4.1.3.2.</span> <span class="nav-text">按周分区</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%89%E6%9C%88%E5%88%86%E5%8C%BA"><span class="nav-number">4.1.3.3.</span> <span class="nav-text">按月分区</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%89%E5%B9%B4%E5%88%86%E5%8C%BA"><span class="nav-number">4.1.3.4.</span> <span class="nav-text">按年分区</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8C%BA%E5%9D%97%E9%AB%98%E5%BA%A6%E4%B8%8E%E6%97%B6%E9%97%B4"><span class="nav-number">4.2.</span> <span class="nav-text">区块高度与时间</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%AB%98%E5%BA%A6%E8%BD%AC%E6%8D%A2%E6%97%B6%E9%97%B4"><span class="nav-number">4.2.1.</span> <span class="nav-text">高度转换时间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E8%BD%AC%E6%8D%A2%E9%AB%98%E5%BA%A6"><span class="nav-number">4.2.2.</span> <span class="nav-text">时间转换高度</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E5%88%86%E5%8C%BA%E5%90%8D%E7%A7%B0"><span class="nav-number">4.3.</span> <span class="nav-text">获取分区名称</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E5%88%86%E5%8C%BA%E8%A1%A8%E5%88%86%E5%8C%BA%E9%94%AE%EF%BC%88%E5%BA%9F%E5%BC%83%E2%9A%A0%EF%B8%8F-at-2022-03-25%EF%BC%89"><span class="nav-number">4.4.</span> <span class="nav-text">获取分区表分区键（废弃⚠️ at 2022-03-25）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E6%9B%B4%E6%96%B0%E5%94%AF%E4%B8%80%E9%94%AE%EF%BC%882022-03-25-%E6%96%B0%E5%A2%9E%EF%BC%89"><span class="nav-number">4.5.</span> <span class="nav-text">获取更新唯一键（2022-03-25 新增）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E5%88%86%E5%8C%BA%E8%A1%A8%E6%9B%B4%E6%96%B0%E5%88%97%E6%A8%A1%E7%89%88"><span class="nav-number">4.6.</span> <span class="nav-text">获取分区表更新列模版</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E6%96%B0%E5%88%86%E5%8C%BA"><span class="nav-number">4.7.</span> <span class="nav-text">创建新分区</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E5%8C%BAMeta%E8%A1%A8"><span class="nav-number">4.7.1.</span> <span class="nav-text">分区Meta表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E5%87%BD%E6%95%B0"><span class="nav-number">4.7.2.</span> <span class="nav-text">主函数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%87%8D%E5%86%99%E8%A7%84%E5%88%99"><span class="nav-number">5.</span> <span class="nav-text">重写规则</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%86%E5%A4%87%E5%88%86%E5%8C%BA%E8%A1%A8"><span class="nav-number">5.1.</span> <span class="nav-text">准备分区表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%EF%BC%88INSERT%EF%BC%89"><span class="nav-number">5.2.</span> <span class="nav-text">插入（INSERT）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E8%B7%AF%E7%94%B1"><span class="nav-number">5.2.1.</span> <span class="nav-text">自动路由</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E5%94%AF%E4%B8%80%E9%94%AE%E5%86%B2%E7%AA%81"><span class="nav-number">5.2.2.</span> <span class="nav-text">处理唯一键冲突</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="nav-number">5.2.3.</span> <span class="nav-text">具体实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9B%B4%E6%96%B0%EF%BC%88UPDATE%EF%BC%89"><span class="nav-number">5.3.</span> <span class="nav-text">更新（UPDATE）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%99%AE%E9%80%9A%E6%9B%B4%E6%96%B0"><span class="nav-number">5.3.1.</span> <span class="nav-text">普通更新</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E5%8C%BA%E7%A7%BB%E5%8A%A8"><span class="nav-number">5.3.2.</span> <span class="nav-text">分区移动</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0-1"><span class="nav-number">5.3.3.</span> <span class="nav-text">具体实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%88%86%E5%8C%BA%E8%A1%A8%E7%BB%B4%E6%8A%A4"><span class="nav-number">6.</span> <span class="nav-text">分区表维护</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%84%E5%88%99%E6%9B%BF%E6%8D%A2"><span class="nav-number">6.1.</span> <span class="nav-text">规则替换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A3%81%E5%89%AA"><span class="nav-number">6.2.</span> <span class="nav-text">裁剪</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%82%E8%BD%BD"><span class="nav-number">6.3.</span> <span class="nav-text">挂载</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">7.</span> <span class="nav-text">总结</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E8%87%AA%E5%8A%A8%E5%88%86%E5%8C%BA%E8%A1%A8%E7%9A%84%E6%AD%A5%E9%AA%A4"><span class="nav-number">7.1.</span> <span class="nav-text">创建自动分区表的步骤</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C"><span class="nav-number">7.2.</span> <span class="nav-text">测试结果</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="nav-number">8.</span> <span class="nav-text">参考资料</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3"><span class="nav-number">8.1.</span> <span class="nav-text">官方文档</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BD%91%E4%B8%8A%E6%96%87%E7%AB%A0"><span class="nav-number">8.2.</span> <span class="nav-text">网上文章</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="alpha"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">alpha</p>
  <div class="site-description" itemprop="description">记录工作中研究和学习的内容，把他们以文字的形式记录下来，备忘。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">44</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">35</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/alphaqiu" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;alphaqiu" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:alphaqiu@gmail.com" title="E-Mail → mailto:alphaqiu@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i></a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">alpha</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v6.3.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.7.2
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://alphaqiu.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>
<script>
  var disqus_config = function() {
    this.page.url = "https://alpha.checkitout.dev/auto-create-partition-tables/";
    this.page.identifier = "/auto-create-partition-tables/";
    this.page.title = "基于PG自动创建分区表的一种实现";
    };
  NexT.utils.loadComments(document.querySelector('#disqus_thread'), () => {
    if (window.DISQUS) {
      DISQUS.reset({
        reload: true,
        config: disqus_config
      });
    } else {
      var d = document, s = d.createElement('script');
      s.src = 'https://alphaqiu.disqus.com/embed.js';
      s.setAttribute('data-timestamp', '' + +new Date());
      (d.head || d.body).appendChild(s);
    }
  });
</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</body>
</html>
